// VRM/GLTF/GLB Viewer using Sokol
// A simple 3D model viewer for VRM, GLTF, and GLB files

#define HANDMADE_MATH_USE_DEGREES
#include "HandmadeMath.h"

#define SOKOL_IMPL
#include "sokol_app.h"
#include "sokol_gfx.h"
#include "sokol_log.h"
#include "sokol_glue.h"

#define CGLTF_IMPLEMENTATION
#include "cgltf/cgltf.h"

#include "nlohmann/json.hpp"

#define USE_VRMC_VRM_0_0
#define USE_VRMC_VRM_1_0
#include <VRMC/VRM.h>

#define STB_IMAGE_IMPLEMENTATION
#define STBI_WINDOWS_UTF8
#include "stb_image.h"

#include <vector>
#include <string>
#include <cstdio>
#include <cmath>
#include <random>
#include <thread>
#include "parallel-util.hpp"

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#endif

// ============================================================================
// Shader (generated by sokol-shdc)
// ============================================================================
#include "shader/mesh.glsl.h"
#include "shader/pbr.glsl.h"
#include "shader/skybox.glsl.h"
#include "shader/toon.glsl.h"

// ============================================================================
// Mesh structure for rendering
// ============================================================================

struct Vertex {
    float pos[3];
    float normal[3];
    float uv[2];
    float tangent[4];  // xyz = tangent, w = sign for bitangent
};

struct PBRMaterial {
    sg_image base_color_tex;
    sg_view base_color_view;
    sg_image metallic_roughness_tex;
    sg_view metallic_roughness_view;
    sg_image normal_tex;
    sg_view normal_view;
    sg_image occlusion_tex;
    sg_view occlusion_view;
    sg_image emissive_tex;
    sg_view emissive_view;
    
    HMM_Vec4 base_color_factor;
    float metallic_factor;
    float roughness_factor;
    HMM_Vec3 emissive_factor;
    
    bool is_vrm;  // Use toon shader for VRM models
    float toon_ramp_steps;
    float toon_rim_power;
    float toon_rim_strength;
};

struct RenderMesh {
    sg_buffer vertex_buffer;
    sg_buffer index_buffer;
    int num_indices;
    bool has_indices;
    int num_vertices;
    PBRMaterial material;
};

struct Model {
    std::vector<RenderMesh> meshes;
    HMM_Vec3 center;
    float radius;
};

// ============================================================================
// Global state
// ============================================================================

static struct {
    // Old simple pipeline
    sg_pipeline pip;
    sg_sampler smp;
    
    // PBR pipelines
    sg_pipeline pbr_pip;
    sg_pipeline toon_pip;
    sg_pipeline skybox_pip;
    
    // Default textures
    sg_image default_texture;
    sg_view default_texture_view;
    sg_image default_normal;
    sg_view default_normal_view;
    sg_image default_metallic_roughness;
    sg_view default_metallic_roughness_view;
    
    // IBL resources
    sg_image hdr_environment;
    sg_view hdr_environment_view;
    sg_image irradiance_map;
    sg_view irradiance_map_view;
    sg_image prefilter_map;
    sg_view prefilter_map_view;
    sg_image brdf_lut;
    sg_view brdf_lut_view;
    
    // Skybox
    sg_buffer skybox_vertex_buffer;
    sg_buffer skybox_index_buffer;
    
    Model model;
    bool model_loaded;
    bool is_vrm_model;
    
    // Camera
    float cam_distance;
    float cam_azimuth;
    float cam_elevation;
    HMM_Vec3 cam_target;
    
    // Input
    bool mouse_down;
    float last_mouse_x;
    float last_mouse_y;
    
    // Animation
    float time;
    
    // Skybox settings
    float skybox_lod;
    float skybox_exposure;
    bool show_skybox;
} state;

// ============================================================================
// Helper functions
// ============================================================================

static void log_message(const char* msg) {
    printf("[VRM Viewer] %s\n", msg);
}

// ============================================================================
// UTF-8 file reading support for Windows
// ============================================================================

#ifdef _WIN32
static std::wstring utf8_to_wstring(const char* utf8_str) {
    if (!utf8_str || !*utf8_str) return L"";
    int len = MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, nullptr, 0);
    if (len <= 0) return L"";
    std::wstring result(len - 1, L'\0');
    MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, &result[0], len);
    return result;
}

static bool read_file_utf8(const char* filepath, std::vector<uint8_t>& out_data) {
    std::wstring wpath = utf8_to_wstring(filepath);
    HANDLE hFile = CreateFileW(wpath.c_str(), GENERIC_READ, FILE_SHARE_READ, 
                               nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hFile == INVALID_HANDLE_VALUE) {
        return false;
    }
    
    LARGE_INTEGER fileSize;
    if (!GetFileSizeEx(hFile, &fileSize)) {
        CloseHandle(hFile);
        return false;
    }
    
    out_data.resize((size_t)fileSize.QuadPart);
    DWORD bytesRead;
    BOOL success = ReadFile(hFile, out_data.data(), (DWORD)fileSize.QuadPart, &bytesRead, nullptr);
    CloseHandle(hFile);
    
    return success && bytesRead == fileSize.QuadPart;
}

static FILE* fopen_utf8(const char* filepath, const char* mode) {
    std::wstring wpath = utf8_to_wstring(filepath);
    std::wstring wmode = utf8_to_wstring(mode);
    return _wfopen(wpath.c_str(), wmode.c_str());
}
#else
static bool read_file_utf8(const char* filepath, std::vector<uint8_t>& out_data) {
    FILE* f = fopen(filepath, "rb");
    if (!f) return false;
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    out_data.resize(size);
    size_t read = fread(out_data.data(), 1, size, f);
    fclose(f);
    
    return read == (size_t)size;
}

static FILE* fopen_utf8(const char* filepath, const char* mode) {
    return fopen(filepath, mode);
}
#endif

static sg_view create_texture_view(sg_image img) {
    sg_view_desc view_desc = {};
    view_desc.texture.image = img;
    // For cubemap, slices must be base=0, count=1 (entire cubemap)
    view_desc.texture.slices.base = 0;
    view_desc.texture.slices.count = 1;
    view_desc.texture.mip_levels.base = 0;
    view_desc.texture.mip_levels.count = 1;
    return sg_make_view(&view_desc);
}

static sg_image create_default_white_texture() {
    uint32_t pixels[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
    sg_image_desc desc = {};
    desc.width = 2;
    desc.height = 2;
    desc.data.mip_levels[0] = { pixels, sizeof(pixels) };
    desc.label = "default-texture";
    return sg_make_image(&desc);
}

static sg_image load_texture_from_buffer(const uint8_t* data, size_t size) {
    int width, height, channels;
    stbi_set_flip_vertically_on_load(0);
    uint8_t* pixels = stbi_load_from_memory(data, (int)size, &width, &height, &channels, 4);
    if (!pixels) {
        log_message("Failed to load texture from buffer");
        return state.default_texture;
    }
    
    sg_image_desc desc = {};
    desc.width = width;
    desc.height = height;
    desc.data.mip_levels[0] = { pixels, (size_t)(width * height * 4) };
    sg_image img = sg_make_image(&desc);
    
    stbi_image_free(pixels);
    return img;
}

static sg_image load_texture_from_file(const char* base_path, const char* uri) {
    // Build full path
    std::string path = base_path;
    size_t last_slash = path.find_last_of("/\\");
    if (last_slash != std::string::npos) {
        path = path.substr(0, last_slash + 1);
    } else {
        path = "";
    }
    path += uri;
    
    // Read file with UTF-8 support
    std::vector<uint8_t> file_data;
    if (!read_file_utf8(path.c_str(), file_data)) {
        log_message(("Failed to read texture file: " + path).c_str());
        return state.default_texture;
    }
    
    int width, height, channels;
    stbi_set_flip_vertically_on_load(0);
    uint8_t* pixels = stbi_load_from_memory(file_data.data(), (int)file_data.size(), &width, &height, &channels, 4);
    if (!pixels) {
        log_message(("Failed to decode texture: " + path).c_str());
        return state.default_texture;
    }
    
    sg_image_desc desc = {};
    desc.width = width;
    desc.height = height;
    desc.data.mip_levels[0] = { pixels, (size_t)(width * height * 4) };
    sg_image img = sg_make_image(&desc);
    
    stbi_image_free(pixels);
    log_message(("Loaded texture: " + path).c_str());
    return img;
}

// ============================================================================
// HDR Loading and IBL
// ============================================================================

static sg_image load_hdr_texture(const char* filepath) {
    int width, height, channels;
    stbi_set_flip_vertically_on_load(1);
    float* hdr_data = stbi_loadf(filepath, &width, &height, &channels, 3);
    if (!hdr_data) {
        log_message(("Failed to load HDR: " + std::string(filepath)).c_str());
        return state.default_texture;
    }
    
    // Convert to RGBA8 for now (simplified - in production use HDR format)
    std::vector<uint8_t> rgba_data(width * height * 4);
    for (int i = 0; i < width * height; i++) {
        rgba_data[i * 4 + 0] = (uint8_t)(fminf(hdr_data[i * 3 + 0] * 255.0f, 255.0f));
        rgba_data[i * 4 + 1] = (uint8_t)(fminf(hdr_data[i * 3 + 1] * 255.0f, 255.0f));
        rgba_data[i * 4 + 2] = (uint8_t)(fminf(hdr_data[i * 3 + 2] * 255.0f, 255.0f));
        rgba_data[i * 4 + 3] = 255;
    }
    
    sg_image_desc desc = {};
    desc.width = width;
    desc.height = height;
    desc.data.mip_levels[0] = { rgba_data.data(), rgba_data.size() };
    desc.label = "hdr-environment";
    sg_image img = sg_make_image(&desc);
    
    stbi_image_free(hdr_data);
    log_message(("Loaded HDR: " + std::string(filepath)).c_str());
    return img;
}

// Generate BRDF LUT (parallelized CPU version)
static sg_image generate_brdf_lut() {
    const int size = 512;
    std::vector<float> lut_data(size * size * 2);
    
    // Use parallel_for_2d to parallelize the computation
    parallelutil::parallel_for_2d(size, size, [&](int x, int y) {
        float NdotV = (x + 0.5f) / size;
        float roughness = (y + 0.5f) / size;
        
        float V[3] = { sqrtf(1.0f - NdotV * NdotV), 0.0f, NdotV };
        float A = 0.0f, B = 0.0f;
        
        // Use deterministic random number generator based on pixel position
        // This ensures reproducible results and thread safety
        std::mt19937 rng(static_cast<unsigned int>(x * size + y));
        std::uniform_real_distribution<float> dist(0.0f, 1.0f);
        
        const int num_samples = 1024;
        for (int i = 0; i < num_samples; i++) {
            float Xi1 = dist(rng);
            float Xi2 = dist(rng);
            
            float phi = 2.0f * 3.14159265359f * Xi1;
            float cosTheta = sqrtf((1.0f - Xi2) / (1.0f + (roughness * roughness - 1.0f) * Xi2));
            float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
            
            float H[3] = {
                cosf(phi) * sinTheta,
                sinf(phi) * sinTheta,
                cosTheta
            };
            
            float NdotH = H[2];
            float VdotH = V[0] * H[0] + V[1] * H[1] + V[2] * H[2];
            
            if (NdotH > 0.0f && VdotH > 0.0f) {
                float G = 2.0f * NdotH / VdotH;
                G = fminf(G, 1.0f);
                float G_Vis = G * VdotH / (NdotH * NdotV);
                float Fc = powf(std::max(1.0f - VdotH, 0.0f), 5.0f);
                A += (1.0f - Fc) * G_Vis;
                B += Fc * G_Vis;
            }
        }
        
        lut_data[(y * size + x) * 2 + 0] = A / num_samples;
        lut_data[(y * size + x) * 2 + 1] = B / num_samples;
    });
    
    // Convert to RG16F format (simplified - using RGBA8)
    std::vector<uint8_t> rgba_data(size * size * 4);
    for (int i = 0; i < size * size; i++) {
        rgba_data[i * 4 + 0] = (uint8_t)(fminf(lut_data[i * 2 + 0] * 255.0f, 255.0f));
        rgba_data[i * 4 + 1] = (uint8_t)(fminf(lut_data[i * 2 + 1] * 255.0f, 255.0f));
        rgba_data[i * 4 + 2] = 0;
        rgba_data[i * 4 + 3] = 255;
    }
    
    sg_image_desc desc = {};
    desc.width = size;
    desc.height = size;
    desc.data.mip_levels[0] = { rgba_data.data(), rgba_data.size() };
    desc.label = "brdf-lut";
    return sg_make_image(&desc);
}

// Create a simple cubemap placeholder
static sg_image create_simple_cubemap(uint8_t r, uint8_t g, uint8_t b) {
    const int size = 64;
    const int face_size = size * size * 4;  // RGBA8 per face
    std::vector<uint8_t> cubemap_data(face_size * 6);  // 6 faces
    
    // Fill all 6 faces with the same color
    for (int face = 0; face < 6; face++) {
        uint8_t* face_data = cubemap_data.data() + face * face_size;
        for (int i = 0; i < size * size; i++) {
            face_data[i * 4 + 0] = r;
            face_data[i * 4 + 1] = g;
            face_data[i * 4 + 2] = b;
            face_data[i * 4 + 3] = 255;
        }
    }
    
    sg_image_desc desc = {};
    desc.type = SG_IMAGETYPE_CUBE;
    desc.width = size;
    desc.height = size;
    desc.num_slices = 6;  // Required for cubemap
    desc.pixel_format = SG_PIXELFORMAT_RGBA8;  // Explicitly set pixel format
    // For cubemap, each mip level contains all 6 faces in order: +X, -X, +Y, -Y, +Z, -Z
    desc.data.mip_levels[0] = { cubemap_data.data(), cubemap_data.size() };
    desc.label = "simple-cubemap";
    return sg_make_image(&desc);
}

// Create simplified IBL maps (in production, use proper GPU-based prefiltering)
static void create_ibl_maps(sg_image hdr_env) {
    // Create placeholder cubemaps for now
    // In production, implement proper equirectangular to cubemap conversion
    // and prefiltering with mipmaps
    
    // Create simple irradiance cubemap (darker blue-gray)
    state.irradiance_map = create_simple_cubemap(50, 60, 70);
    state.irradiance_map_view = create_texture_view(state.irradiance_map);
    
    // Create simple prefilter cubemap (slightly brighter)
    state.prefilter_map = create_simple_cubemap(80, 90, 100);
    state.prefilter_map_view = create_texture_view(state.prefilter_map);
    
    state.brdf_lut = generate_brdf_lut();
    state.brdf_lut_view = create_texture_view(state.brdf_lut);
    
    log_message("IBL maps created (placeholder cubemaps - need proper conversion)");
}

// ============================================================================
// GLTF/GLB/VRM Loading
// ============================================================================

// Custom cgltf file read callback for UTF-8 path support
static cgltf_result cgltf_read_file_utf8(const cgltf_memory_options* memory_options, 
                                          const cgltf_file_options* file_options,
                                          const char* path, cgltf_size* size, void** data) {
    (void)file_options;
    
    std::vector<uint8_t> file_data;
    if (!read_file_utf8(path, file_data)) {
        return cgltf_result_file_not_found;
    }
    
    void* (*memory_alloc)(void*, cgltf_size) = memory_options->alloc ? memory_options->alloc : &cgltf_default_alloc;
    void* result = memory_alloc(memory_options->user_data, file_data.size());
    if (!result) {
        return cgltf_result_out_of_memory;
    }
    
    memcpy(result, file_data.data(), file_data.size());
    *size = file_data.size();
    *data = result;
    
    return cgltf_result_success;
}

static void cgltf_release_file_utf8(const cgltf_memory_options* memory_options,
                                     const cgltf_file_options* file_options, void* data) {
    (void)file_options;
    void (*memory_free)(void*, void*) = memory_options->free ? memory_options->free : &cgltf_default_free;
    memory_free(memory_options->user_data, data);
}

static bool load_model(const char* filepath) {
    log_message(("Loading model: " + std::string(filepath)).c_str());
    
    // Read file with UTF-8 support
    std::vector<uint8_t> file_data;
    if (!read_file_utf8(filepath, file_data)) {
        log_message("Failed to read model file");
        return false;
    }
    
    cgltf_options options = {};
    options.file.read = cgltf_read_file_utf8;
    options.file.release = cgltf_release_file_utf8;
    
    cgltf_data* data = nullptr;
    
    // Parse from memory
    cgltf_result result = cgltf_parse(&options, file_data.data(), file_data.size(), &data);
    if (result != cgltf_result_success) {
        log_message("Failed to parse GLTF file");
        return false;
    }
    
    // Load buffers (uses our custom file read callback for external files)
    result = cgltf_load_buffers(&options, data, filepath);
    if (result != cgltf_result_success) {
        log_message("Failed to load GLTF buffers");
        cgltf_free(data);
        return false;
    }
    
    // Check if VRM model
    state.is_vrm_model = false;
    if (data->extensions_used && data->extensions_used_count > 0) {
        for (size_t i = 0; i < data->extensions_used_count; i++) {
            if (strstr(data->extensions_used[i], "VRM") || strstr(data->extensions_used[i], "vrm")) {
                state.is_vrm_model = true;
                break;
            }
        }
    }
    
    // Clear existing model
    for (auto& mesh : state.model.meshes) {
        sg_destroy_buffer(mesh.vertex_buffer);
        if (mesh.has_indices) {
            sg_destroy_buffer(mesh.index_buffer);
        }
        // Clean up PBR material textures
        if (mesh.material.base_color_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.base_color_view);
            sg_destroy_image(mesh.material.base_color_tex);
        }
        if (mesh.material.metallic_roughness_tex.id != state.default_metallic_roughness.id) {
            sg_destroy_view(mesh.material.metallic_roughness_view);
            sg_destroy_image(mesh.material.metallic_roughness_tex);
        }
        if (mesh.material.normal_tex.id != state.default_normal.id) {
            sg_destroy_view(mesh.material.normal_view);
            sg_destroy_image(mesh.material.normal_tex);
        }
        if (mesh.material.occlusion_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.occlusion_view);
            sg_destroy_image(mesh.material.occlusion_tex);
        }
        if (mesh.material.emissive_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.emissive_view);
            sg_destroy_image(mesh.material.emissive_tex);
        }
    }
    state.model.meshes.clear();
    
    // Calculate bounding box for camera positioning
    HMM_Vec3 min_bounds = HMM_V3(1e10f, 1e10f, 1e10f);
    HMM_Vec3 max_bounds = HMM_V3(-1e10f, -1e10f, -1e10f);
    
    // Load textures
    std::vector<sg_image> textures(data->images_count, state.default_texture);
    std::vector<sg_view> texture_views(data->images_count, state.default_texture_view);
    for (size_t i = 0; i < data->images_count; i++) {
        cgltf_image* image = &data->images[i];
        
        if (image->buffer_view) {
            // Embedded texture
            const uint8_t* buffer_data = (const uint8_t*)image->buffer_view->buffer->data;
            buffer_data += image->buffer_view->offset;
            textures[i] = load_texture_from_buffer(buffer_data, image->buffer_view->size);
        } else if (image->uri) {
            // External texture file
            textures[i] = load_texture_from_file(filepath, image->uri);
        }
        
        // Create view for texture if it's not the default
        if (textures[i].id != state.default_texture.id) {
            texture_views[i] = create_texture_view(textures[i]);
        }
    }
    
    // Process all meshes in all nodes
    for (size_t ni = 0; ni < data->nodes_count; ni++) {
        cgltf_node* node = &data->nodes[ni];
        if (!node->mesh) continue;
        
        // Get node transform
        float node_matrix[16];
        cgltf_node_transform_world(node, node_matrix);
        
        cgltf_mesh* mesh = node->mesh;
        
        for (size_t pi = 0; pi < mesh->primitives_count; pi++) {
            cgltf_primitive* prim = &mesh->primitives[pi];
            
            if (prim->type != cgltf_primitive_type_triangles) {
                continue;
            }
            
            // Find position, normal, texcoord, and tangent accessors
            cgltf_accessor* pos_accessor = nullptr;
            cgltf_accessor* norm_accessor = nullptr;
            cgltf_accessor* uv_accessor = nullptr;
            cgltf_accessor* tangent_accessor = nullptr;
            
            for (size_t ai = 0; ai < prim->attributes_count; ai++) {
                cgltf_attribute* attr = &prim->attributes[ai];
                switch (attr->type) {
                    case cgltf_attribute_type_position:
                        pos_accessor = attr->data;
                        break;
                    case cgltf_attribute_type_normal:
                        norm_accessor = attr->data;
                        break;
                    case cgltf_attribute_type_texcoord:
                        if (attr->index == 0) {
                            uv_accessor = attr->data;
                        }
                        break;
                    case cgltf_attribute_type_tangent:
                        tangent_accessor = attr->data;
                        break;
                    default:
                        break;
                }
            }
            
            if (!pos_accessor) {
                continue;
            }
            
            size_t vertex_count = pos_accessor->count;
            std::vector<Vertex> vertices(vertex_count);
            
            // Read positions
            for (size_t vi = 0; vi < vertex_count; vi++) {
                float pos[3] = {0, 0, 0};
                cgltf_accessor_read_float(pos_accessor, vi, pos, 3);
                
                // Apply node transform
                float tx = node_matrix[0]*pos[0] + node_matrix[4]*pos[1] + node_matrix[8]*pos[2] + node_matrix[12];
                float ty = node_matrix[1]*pos[0] + node_matrix[5]*pos[1] + node_matrix[9]*pos[2] + node_matrix[13];
                float tz = node_matrix[2]*pos[0] + node_matrix[6]*pos[1] + node_matrix[10]*pos[2] + node_matrix[14];
                
                vertices[vi].pos[0] = tx;
                vertices[vi].pos[1] = ty;
                vertices[vi].pos[2] = tz;
                
                // Update bounds
                min_bounds.X = HMM_MIN(min_bounds.X, tx);
                min_bounds.Y = HMM_MIN(min_bounds.Y, ty);
                min_bounds.Z = HMM_MIN(min_bounds.Z, tz);
                max_bounds.X = HMM_MAX(max_bounds.X, tx);
                max_bounds.Y = HMM_MAX(max_bounds.Y, ty);
                max_bounds.Z = HMM_MAX(max_bounds.Z, tz);
            }
            
            // Read normals
            if (norm_accessor) {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    float norm[3] = {0, 1, 0};
                    cgltf_accessor_read_float(norm_accessor, vi, norm, 3);
                    
                    // Apply node rotation (ignore scale for normals)
                    float nx = node_matrix[0]*norm[0] + node_matrix[4]*norm[1] + node_matrix[8]*norm[2];
                    float ny = node_matrix[1]*norm[0] + node_matrix[5]*norm[1] + node_matrix[9]*norm[2];
                    float nz = node_matrix[2]*norm[0] + node_matrix[6]*norm[1] + node_matrix[10]*norm[2];
                    float len = sqrtf(nx*nx + ny*ny + nz*nz);
                    if (len > 0.0001f) {
                        vertices[vi].normal[0] = nx / len;
                        vertices[vi].normal[1] = ny / len;
                        vertices[vi].normal[2] = nz / len;
                    } else {
                        vertices[vi].normal[0] = 0;
                        vertices[vi].normal[1] = 1;
                        vertices[vi].normal[2] = 0;
                    }
                }
            } else {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    vertices[vi].normal[0] = 0;
                    vertices[vi].normal[1] = 1;
                    vertices[vi].normal[2] = 0;
                }
            }
            
            // Read UVs
            if (uv_accessor) {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    float uv[2] = {0, 0};
                    cgltf_accessor_read_float(uv_accessor, vi, uv, 2);
                    vertices[vi].uv[0] = uv[0];
                    vertices[vi].uv[1] = uv[1];
                }
            } else {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    vertices[vi].uv[0] = 0;
                    vertices[vi].uv[1] = 0;
                }
            }
            
            // Read tangents
            if (tangent_accessor) {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    float tangent[4] = {1, 0, 0, 1};
                    cgltf_accessor_read_float(tangent_accessor, vi, tangent, 4);
                    
                    // Apply node rotation to tangent
                    float tx = node_matrix[0]*tangent[0] + node_matrix[4]*tangent[1] + node_matrix[8]*tangent[2];
                    float ty = node_matrix[1]*tangent[0] + node_matrix[5]*tangent[1] + node_matrix[9]*tangent[2];
                    float tz = node_matrix[2]*tangent[0] + node_matrix[6]*tangent[1] + node_matrix[10]*tangent[2];
                    float len = sqrtf(tx*tx + ty*ty + tz*tz);
                    if (len > 0.0001f) {
                        vertices[vi].tangent[0] = tx / len;
                        vertices[vi].tangent[1] = ty / len;
                        vertices[vi].tangent[2] = tz / len;
                    } else {
                        vertices[vi].tangent[0] = 1;
                        vertices[vi].tangent[1] = 0;
                        vertices[vi].tangent[2] = 0;
                    }
                    vertices[vi].tangent[3] = tangent[3];  // Sign for bitangent
                }
            } else {
                // Generate default tangent if not present
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    vertices[vi].tangent[0] = 1;
                    vertices[vi].tangent[1] = 0;
                    vertices[vi].tangent[2] = 0;
                    vertices[vi].tangent[3] = 1;
                }
            }
            
            // Create render mesh
            RenderMesh render_mesh = {};
            
            // Create vertex buffer
            sg_buffer_desc vbuf_desc = {};
            vbuf_desc.data = { vertices.data(), vertices.size() * sizeof(Vertex) };
            vbuf_desc.label = "mesh-vertices";
            render_mesh.vertex_buffer = sg_make_buffer(&vbuf_desc);
            render_mesh.num_vertices = (int)vertex_count;
            
            // Read indices if available
            if (prim->indices) {
                size_t index_count = prim->indices->count;
                std::vector<uint32_t> indices(index_count);
                
                for (size_t ii = 0; ii < index_count; ii++) {
                    indices[ii] = (uint32_t)cgltf_accessor_read_index(prim->indices, ii);
                }
                
                sg_buffer_desc ibuf_desc = {};
                ibuf_desc.usage.index_buffer = true;
                ibuf_desc.data = { indices.data(), indices.size() * sizeof(uint32_t) };
                ibuf_desc.label = "mesh-indices";
                render_mesh.index_buffer = sg_make_buffer(&ibuf_desc);
                render_mesh.num_indices = (int)index_count;
                render_mesh.has_indices = true;
            } else {
                render_mesh.has_indices = false;
            }
            
            // Initialize PBR material with defaults
            PBRMaterial material = {};
            material.base_color_tex = state.default_texture;
            material.base_color_view = state.default_texture_view;
            material.metallic_roughness_tex = state.default_metallic_roughness;
            material.metallic_roughness_view = state.default_metallic_roughness_view;
            material.normal_tex = state.default_normal;
            material.normal_view = state.default_normal_view;
            material.occlusion_tex = state.default_texture;
            material.occlusion_view = state.default_texture_view;
            material.emissive_tex = state.default_texture;
            material.emissive_view = state.default_texture_view;
            
            material.base_color_factor = HMM_V4(1.0f, 1.0f, 1.0f, 1.0f);
            material.metallic_factor = 1.0f;
            material.roughness_factor = 1.0f;
            material.emissive_factor = HMM_V3(0.0f, 0.0f, 0.0f);
            
            material.is_vrm = state.is_vrm_model;
            material.toon_ramp_steps = 4.0f;
            material.toon_rim_power = 2.0f;
            material.toon_rim_strength = 0.5f;
            
            // Load PBR material from GLTF
            if (prim->material) {
                cgltf_material* mat = prim->material;
                
                if (mat->has_pbr_metallic_roughness) {
                    cgltf_pbr_metallic_roughness* pbr = &mat->pbr_metallic_roughness;
                    
                    material.base_color_factor = HMM_V4(
                        pbr->base_color_factor[0],
                        pbr->base_color_factor[1],
                        pbr->base_color_factor[2],
                        pbr->base_color_factor[3]
                    );
                    material.metallic_factor = pbr->metallic_factor;
                    material.roughness_factor = pbr->roughness_factor;
                    
                    // Base color texture
                    if (pbr->base_color_texture.texture) {
                        cgltf_texture* tex = pbr->base_color_texture.texture;
                        if (tex->image) {
                            size_t img_idx = tex->image - data->images;
                            if (img_idx < textures.size()) {
                                material.base_color_tex = textures[img_idx];
                                material.base_color_view = texture_views[img_idx];
                            }
                        }
                    }
                    
                    // Metallic-roughness texture
                    if (pbr->metallic_roughness_texture.texture) {
                        cgltf_texture* tex = pbr->metallic_roughness_texture.texture;
                        if (tex->image) {
                            size_t img_idx = tex->image - data->images;
                            if (img_idx < textures.size()) {
                                material.metallic_roughness_tex = textures[img_idx];
                                material.metallic_roughness_view = texture_views[img_idx];
                            }
                        }
                    }
                }
                
                // Normal texture
                if (mat->normal_texture.texture) {
                    cgltf_texture* tex = mat->normal_texture.texture;
                    if (tex->image) {
                        size_t img_idx = tex->image - data->images;
                        if (img_idx < textures.size()) {
                            material.normal_tex = textures[img_idx];
                            material.normal_view = texture_views[img_idx];
                        }
                    }
                }
                
                // Occlusion texture
                if (mat->occlusion_texture.texture) {
                    cgltf_texture* tex = mat->occlusion_texture.texture;
                    if (tex->image) {
                        size_t img_idx = tex->image - data->images;
                        if (img_idx < textures.size()) {
                            material.occlusion_tex = textures[img_idx];
                            material.occlusion_view = texture_views[img_idx];
                        }
                    }
                }
                
                // Emissive texture
                if (mat->emissive_texture.texture) {
                    cgltf_texture* tex = mat->emissive_texture.texture;
                    if (tex->image) {
                        size_t img_idx = tex->image - data->images;
                        if (img_idx < textures.size()) {
                            material.emissive_tex = textures[img_idx];
                            material.emissive_view = texture_views[img_idx];
                        }
                    }
                }
                
                material.emissive_factor = HMM_V3(
                    mat->emissive_factor[0],
                    mat->emissive_factor[1],
                    mat->emissive_factor[2]
                );
            }
            
            render_mesh.material = material;
            
            state.model.meshes.push_back(render_mesh);
        }
    }
    
    cgltf_free(data);
    
    // Calculate model center and radius
    state.model.center = HMM_MulV3F(HMM_AddV3(min_bounds, max_bounds), 0.5f);
    HMM_Vec3 extent = HMM_SubV3(max_bounds, min_bounds);
    state.model.radius = HMM_LenV3(extent) * 0.5f;
    
    if (state.model.radius < 0.001f) {
        state.model.radius = 1.0f;
    }
    
    // Set up camera to view the model
    state.cam_target = state.model.center;
    state.cam_distance = state.model.radius * 2.5f;
    state.cam_elevation = 15.0f;
    state.cam_azimuth = 45.0f;
    
    log_message(("Loaded " + std::to_string(state.model.meshes.size()) + " mesh(es)").c_str());
    state.model_loaded = true;
    
    return true;
}

// ============================================================================
// Sokol callbacks
// ============================================================================

static void init() {
    log_message("Initializing...");
    
    // Setup sokol-gfx
    sg_desc desc = {};
    desc.environment = sglue_environment();
    desc.logger.func = slog_func;
    sg_setup(&desc);
    
    // Create default textures
    state.default_texture = create_default_white_texture();
    state.default_texture_view = create_texture_view(state.default_texture);
    
    // Default normal map (neutral blue)
    uint32_t normal_pixels[4] = { 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF };
    sg_image_desc normal_desc = {};
    normal_desc.width = 2;
    normal_desc.height = 2;
    normal_desc.data.mip_levels[0] = { normal_pixels, sizeof(normal_pixels) };
    normal_desc.label = "default-normal";
    state.default_normal = sg_make_image(&normal_desc);
    state.default_normal_view = create_texture_view(state.default_normal);
    
    // Default metallic-roughness (white = fully metallic, fully rough)
    uint32_t mr_pixels[4] = { 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF };
    sg_image_desc mr_desc = {};
    mr_desc.width = 2;
    mr_desc.height = 2;
    mr_desc.data.mip_levels[0] = { mr_pixels, sizeof(mr_pixels) };
    mr_desc.label = "default-metallic-roughness";
    state.default_metallic_roughness = sg_make_image(&mr_desc);
    state.default_metallic_roughness_view = create_texture_view(state.default_metallic_roughness);
    
    // Create samplers
    sg_sampler_desc smp_desc = {};
    smp_desc.min_filter = SG_FILTER_LINEAR;
    smp_desc.mag_filter = SG_FILTER_LINEAR;
    smp_desc.wrap_u = SG_WRAP_REPEAT;
    smp_desc.wrap_v = SG_WRAP_REPEAT;
    state.smp = sg_make_sampler(&smp_desc);
    
    // Cubemap sampler for IBL
    sg_sampler_desc cubemap_smp_desc = {};
    cubemap_smp_desc.min_filter = SG_FILTER_LINEAR;
    cubemap_smp_desc.mag_filter = SG_FILTER_LINEAR;
    cubemap_smp_desc.wrap_u = SG_WRAP_CLAMP_TO_EDGE;
    cubemap_smp_desc.wrap_v = SG_WRAP_CLAMP_TO_EDGE;
    cubemap_smp_desc.wrap_w = SG_WRAP_CLAMP_TO_EDGE;
    sg_sampler cubemap_smp = sg_make_sampler(&cubemap_smp_desc);
    
    // Load HDR environment and create IBL maps
    state.hdr_environment = load_hdr_texture("assets/hdr/modern_evening_street_2k.hdr");
    state.hdr_environment_view = create_texture_view(state.hdr_environment);
    create_ibl_maps(state.hdr_environment);
    
    // Create skybox geometry
    float skybox_vertices[] = {
        -1.0f,  1.0f, -1.0f,  -1.0f, -1.0f, -1.0f,   1.0f, -1.0f, -1.0f,   1.0f, -1.0f, -1.0f,   1.0f,  1.0f, -1.0f,  -1.0f,  1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f,  -1.0f, -1.0f, -1.0f,  -1.0f,  1.0f, -1.0f,  -1.0f,  1.0f, -1.0f,  -1.0f,  1.0f,  1.0f,  -1.0f, -1.0f,  1.0f,
         1.0f, -1.0f, -1.0f,   1.0f, -1.0f,  1.0f,   1.0f,  1.0f,  1.0f,   1.0f,  1.0f,  1.0f,   1.0f,  1.0f, -1.0f,   1.0f, -1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f,  -1.0f,  1.0f,  1.0f,   1.0f,  1.0f,  1.0f,   1.0f,  1.0f,  1.0f,   1.0f, -1.0f,  1.0f,  -1.0f, -1.0f,  1.0f,
        -1.0f,  1.0f, -1.0f,   1.0f,  1.0f, -1.0f,   1.0f,  1.0f,  1.0f,   1.0f,  1.0f,  1.0f,  -1.0f,  1.0f,  1.0f,  -1.0f,  1.0f, -1.0f,
        -1.0f, -1.0f, -1.0f,  -1.0f, -1.0f,  1.0f,   1.0f, -1.0f, -1.0f,   1.0f, -1.0f, -1.0f,  -1.0f, -1.0f,  1.0f,   1.0f, -1.0f,  1.0f
    };
    sg_buffer_desc skybox_vbuf_desc = {};
    skybox_vbuf_desc.data = { skybox_vertices, sizeof(skybox_vertices) };
    skybox_vbuf_desc.label = "skybox-vertices";
    state.skybox_vertex_buffer = sg_make_buffer(&skybox_vbuf_desc);
    
    uint16_t skybox_indices[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35 };
    sg_buffer_desc skybox_ibuf_desc = {};
    skybox_ibuf_desc.usage.index_buffer = true;
    skybox_ibuf_desc.data = { skybox_indices, sizeof(skybox_indices) };
    skybox_ibuf_desc.label = "skybox-indices";
    state.skybox_index_buffer = sg_make_buffer(&skybox_ibuf_desc);
    
    // Create PBR shader
    sg_shader pbr_shd = sg_make_shader(pbr_pbr_shader_desc(sg_query_backend()));
    sg_pipeline_desc pbr_pip_desc = {};
    pbr_pip_desc.shader = pbr_shd;
    pbr_pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT3;  // position
    pbr_pip_desc.layout.attrs[1].format = SG_VERTEXFORMAT_FLOAT3;  // normal
    pbr_pip_desc.layout.attrs[2].format = SG_VERTEXFORMAT_FLOAT2;  // uv
    pbr_pip_desc.layout.attrs[3].format = SG_VERTEXFORMAT_FLOAT4;  // tangent
    pbr_pip_desc.index_type = SG_INDEXTYPE_UINT32;
    pbr_pip_desc.cull_mode = SG_CULLMODE_NONE;
    pbr_pip_desc.depth.write_enabled = true;
    pbr_pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    pbr_pip_desc.label = "pbr-pipeline";
    state.pbr_pip = sg_make_pipeline(&pbr_pip_desc);
    
    // Create toon shader
    sg_shader toon_shd = sg_make_shader(toon_toon_shader_desc(sg_query_backend()));
    sg_pipeline_desc toon_pip_desc = {};
    toon_pip_desc.shader = toon_shd;
    toon_pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT3;  // position
    toon_pip_desc.layout.attrs[1].format = SG_VERTEXFORMAT_FLOAT3;  // normal
    toon_pip_desc.layout.attrs[2].format = SG_VERTEXFORMAT_FLOAT2;  // uv
    toon_pip_desc.layout.attrs[3].format = SG_VERTEXFORMAT_FLOAT4;  // tangent
    toon_pip_desc.index_type = SG_INDEXTYPE_UINT32;
    toon_pip_desc.cull_mode = SG_CULLMODE_NONE;
    toon_pip_desc.depth.write_enabled = true;
    toon_pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    toon_pip_desc.label = "toon-pipeline";
    state.toon_pip = sg_make_pipeline(&toon_pip_desc);
    
    // Create skybox shader
    sg_shader skybox_shd = sg_make_shader(skybox_skybox_shader_desc(sg_query_backend()));
    sg_pipeline_desc skybox_pip_desc = {};
    skybox_pip_desc.shader = skybox_shd;
    skybox_pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT3;  // position
    skybox_pip_desc.index_type = SG_INDEXTYPE_UINT16;
    skybox_pip_desc.cull_mode = SG_CULLMODE_FRONT;  // Inside-out rendering
    skybox_pip_desc.depth.write_enabled = false;
    skybox_pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    skybox_pip_desc.label = "skybox-pipeline";
    state.skybox_pip = sg_make_pipeline(&skybox_pip_desc);
    
    // Old simple pipeline (kept for compatibility)
    sg_shader shd = sg_make_shader(mesh_mesh_shader_desc(sg_query_backend()));
    sg_pipeline_desc pip_desc = {};
    pip_desc.shader = shd;
    pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT3;  // position
    pip_desc.layout.attrs[1].format = SG_VERTEXFORMAT_FLOAT3;  // normal
    pip_desc.layout.attrs[2].format = SG_VERTEXFORMAT_FLOAT2;  // uv
    pip_desc.index_type = SG_INDEXTYPE_UINT32;
    pip_desc.cull_mode = SG_CULLMODE_NONE;
    pip_desc.depth.write_enabled = true;
    pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    pip_desc.label = "mesh-pipeline";
    state.pip = sg_make_pipeline(&pip_desc);
    
    // Initialize camera
    state.cam_distance = 5.0f;
    state.cam_azimuth = 45.0f;
    state.cam_elevation = 20.0f;
    state.cam_target = HMM_V3(0, 0, 0);
    
    state.mouse_down = false;
    state.time = 0.0f;
    state.model_loaded = false;
    state.is_vrm_model = false;
    
    // Skybox settings
    state.skybox_lod = 0.0f;
    state.skybox_exposure = 1.0f;
    state.show_skybox = true;
    
    log_message("Ready. Drag and drop a VRM/GLTF/GLB file to load.");
    log_message("Press 'S' to toggle skybox, '+'/'-' to adjust exposure, '['/']' to adjust LOD");
}

static void frame() {
    state.time += (float)sapp_frame_duration();
    
    // Calculate camera position
    float azimuth_rad = HMM_AngleRad(state.cam_azimuth);
    float elevation_rad = HMM_AngleRad(state.cam_elevation);
    
    float cos_elev = cosf(elevation_rad);
    float sin_elev = sinf(elevation_rad);
    float cos_azim = cosf(azimuth_rad);
    float sin_azim = sinf(azimuth_rad);
    
    HMM_Vec3 cam_offset = HMM_V3(
        cos_elev * sin_azim * state.cam_distance,
        sin_elev * state.cam_distance,
        cos_elev * cos_azim * state.cam_distance
    );
    HMM_Vec3 cam_pos = HMM_AddV3(state.cam_target, cam_offset);
    
    // Build view and projection matrices
    float aspect = sapp_widthf() / sapp_heightf();
    HMM_Mat4 proj = HMM_Perspective_RH_ZO(45.0f, aspect, 0.01f, 1000.0f);
    HMM_Mat4 view = HMM_LookAt_RH(cam_pos, state.cam_target, HMM_V3(0, 1, 0));
    HMM_Mat4 model = HMM_M4D(1.0f);
    HMM_Mat4 mvp = HMM_MulM4(proj, HMM_MulM4(view, model));
    
    // Light direction (from camera towards scene)
    HMM_Vec3 light_dir = HMM_NormV3(HMM_V3(0.5f, 1.0f, 0.3f));
    
    // Build normal matrix for PBR
    HMM_Mat4 normal_matrix = HMM_TransposeM4(HMM_InvGeneralM4(model));
    
    // Begin pass
    sg_pass pass = {};
    pass.swapchain = sglue_swapchain();
    pass.action.colors[0].load_action = SG_LOADACTION_CLEAR;
    pass.action.colors[0].clear_value = { 0.0f, 0.0f, 0.0f, 1.0f };
    pass.action.depth.load_action = SG_LOADACTION_CLEAR;
    pass.action.depth.clear_value = 1.0f;
    sg_begin_pass(&pass);
    
    // Render skybox first (if enabled)
    if (state.show_skybox && state.hdr_environment.id != SG_INVALID_ID) {
        sg_apply_pipeline(state.skybox_pip);
        
        sg_bindings skybox_bind = {};
        skybox_bind.vertex_buffers[0] = state.skybox_vertex_buffer;
        skybox_bind.index_buffer = state.skybox_index_buffer;
        skybox_bind.views[VIEW_skybox_environment_map] = state.prefilter_map_view;  // Use prefilter map for skybox
        skybox_bind.samplers[SMP_skybox_env_smp] = state.smp;
        sg_apply_bindings(&skybox_bind);
        
        // Skybox uses view matrix without translation
        HMM_Mat4 skybox_view = view;
        skybox_view.Elements[0][3] = 0.0f;
        skybox_view.Elements[1][3] = 0.0f;
        skybox_view.Elements[2][3] = 0.0f;
        skybox_view.Elements[3][0] = 0.0f;
        skybox_view.Elements[3][1] = 0.0f;
        skybox_view.Elements[3][2] = 0.0f;
        HMM_Mat4 skybox_mvp = HMM_MulM4(proj, skybox_view);
        
        // Skybox vertex shader uniforms
        skybox_vs_params_t skybox_vs = {};
        skybox_vs.mvp = skybox_mvp;
        skybox_vs.cam_pos = cam_pos;
        sg_apply_uniforms(UB_skybox_vs_params, SG_RANGE(skybox_vs));
        
        // Skybox fragment shader uniforms
        skybox_fs_params_t skybox_fs = {};
        skybox_fs.lod_level = state.skybox_lod;
        skybox_fs.exposure = state.skybox_exposure;
        sg_apply_uniforms(UB_skybox_fs_params, SG_RANGE(skybox_fs));
        
        sg_draw(0, 36, 1);
    }
    
    // Render model with PBR or toon shader
    if (state.model_loaded) {
        for (auto& mesh : state.model.meshes) {
            // Choose shader based on material
            if (mesh.material.is_vrm) {
                sg_apply_pipeline(state.toon_pip);
            } else {
                sg_apply_pipeline(state.pbr_pip);
            }
            
            // Set up bindings
            sg_bindings bind = {};
            bind.vertex_buffers[0] = mesh.vertex_buffer;
            if (mesh.has_indices) {
                bind.index_buffer = mesh.index_buffer;
            }
            
            // PBR/Toon texture bindings (using generated constants)
            if (mesh.material.is_vrm) {
                // Toon shader bindings
                bind.views[VIEW_toon_base_color_tex] = mesh.material.base_color_view;
                bind.samplers[SMP_toon_base_color_smp] = state.smp;
                bind.views[VIEW_toon_metallic_roughness_tex] = mesh.material.metallic_roughness_view;
                bind.samplers[SMP_toon_metallic_roughness_smp] = state.smp;
                bind.views[VIEW_toon_irradiance_map] = state.irradiance_map_view;
                bind.samplers[SMP_toon_irradiance_smp] = state.smp;
                bind.views[VIEW_toon_prefilter_map] = state.prefilter_map_view;
                bind.samplers[SMP_toon_prefilter_smp] = state.smp;
                bind.views[VIEW_toon_brdf_lut] = state.brdf_lut_view;
                bind.samplers[SMP_toon_brdf_lut_smp] = state.smp;
            } else {
                // PBR shader bindings
                bind.views[VIEW_pbr_base_color_tex] = mesh.material.base_color_view;
                bind.samplers[SMP_pbr_base_color_smp] = state.smp;
                bind.views[VIEW_pbr_metallic_roughness_tex] = mesh.material.metallic_roughness_view;
                bind.samplers[SMP_pbr_metallic_roughness_smp] = state.smp;
                bind.views[VIEW_pbr_normal_tex] = mesh.material.normal_view;
                bind.samplers[SMP_pbr_normal_smp] = state.smp;
                bind.views[VIEW_pbr_occlusion_tex] = mesh.material.occlusion_view;
                bind.samplers[SMP_pbr_occlusion_smp] = state.smp;
                bind.views[VIEW_pbr_emissive_tex] = mesh.material.emissive_view;
                bind.samplers[SMP_pbr_emissive_smp] = state.smp;
                bind.views[VIEW_pbr_irradiance_map] = state.irradiance_map_view;
                bind.samplers[SMP_pbr_irradiance_smp] = state.smp;
                bind.views[VIEW_pbr_prefilter_map] = state.prefilter_map_view;
                bind.samplers[SMP_pbr_prefilter_smp] = state.smp;
                bind.views[VIEW_pbr_brdf_lut] = state.brdf_lut_view;
                bind.samplers[SMP_pbr_brdf_lut_smp] = state.smp;
            }
            
            sg_apply_bindings(&bind);
            
            // Vertex shader uniforms
            if (mesh.material.is_vrm) {
                toon_vs_params_t vs_uniforms = {};
                vs_uniforms.mvp = mvp;
                vs_uniforms.model = model;
                vs_uniforms.normal_matrix = normal_matrix;
                vs_uniforms.cam_pos = cam_pos;
                sg_apply_uniforms(UB_toon_vs_params, SG_RANGE(vs_uniforms));
            } else {
                pbr_vs_params_t vs_uniforms = {};
                vs_uniforms.mvp = mvp;
                vs_uniforms.model = model;
                vs_uniforms.normal_matrix = normal_matrix;
                vs_uniforms.cam_pos = cam_pos;
                sg_apply_uniforms(UB_pbr_vs_params, SG_RANGE(vs_uniforms));
            }
            
            // Fragment shader uniforms
            if (mesh.material.is_vrm) {
                toon_fs_params_t fs_uniforms = {};
                fs_uniforms.base_color_factor = mesh.material.base_color_factor;
                fs_uniforms.metallic_factor = mesh.material.metallic_factor;
                fs_uniforms.roughness_factor = mesh.material.roughness_factor;
                fs_uniforms.toon_ramp_steps = mesh.material.toon_ramp_steps;
                fs_uniforms.toon_rim_power = mesh.material.toon_rim_power;
                fs_uniforms.toon_rim_strength = mesh.material.toon_rim_strength;
                fs_uniforms.cam_pos = cam_pos;
                sg_apply_uniforms(UB_toon_fs_params, SG_RANGE(fs_uniforms));
            } else {
                pbr_fs_params_t fs_uniforms = {};
                fs_uniforms.base_color_factor = mesh.material.base_color_factor;
                fs_uniforms.metallic_factor = mesh.material.metallic_factor;
                fs_uniforms.roughness_factor = mesh.material.roughness_factor;
                fs_uniforms.emissive_factor = mesh.material.emissive_factor;
                fs_uniforms.cam_pos = cam_pos;
                sg_apply_uniforms(UB_pbr_fs_params, SG_RANGE(fs_uniforms));
            }
            
            // Draw
            if (mesh.has_indices) {
                sg_draw(0, mesh.num_indices, 1);
            } else {
                sg_draw(0, mesh.num_vertices, 1);
            }
        }
    }
    
    sg_end_pass();
    sg_commit();
}

static void cleanup() {
    log_message("Cleaning up...");
    
    // Clean up model resources
    for (auto& mesh : state.model.meshes) {
        sg_destroy_buffer(mesh.vertex_buffer);
        if (mesh.has_indices) {
            sg_destroy_buffer(mesh.index_buffer);
        }
        // Clean up PBR material textures
        if (mesh.material.base_color_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.base_color_view);
            sg_destroy_image(mesh.material.base_color_tex);
        }
        if (mesh.material.metallic_roughness_tex.id != state.default_metallic_roughness.id) {
            sg_destroy_view(mesh.material.metallic_roughness_view);
            sg_destroy_image(mesh.material.metallic_roughness_tex);
        }
        if (mesh.material.normal_tex.id != state.default_normal.id) {
            sg_destroy_view(mesh.material.normal_view);
            sg_destroy_image(mesh.material.normal_tex);
        }
        if (mesh.material.occlusion_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.occlusion_view);
            sg_destroy_image(mesh.material.occlusion_tex);
        }
        if (mesh.material.emissive_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.emissive_view);
            sg_destroy_image(mesh.material.emissive_tex);
        }
    }
    
    // Clean up skybox
    sg_destroy_buffer(state.skybox_vertex_buffer);
    sg_destroy_buffer(state.skybox_index_buffer);
    
    // Clean up IBL resources
    sg_destroy_view(state.brdf_lut_view);
    sg_destroy_image(state.brdf_lut);
    sg_destroy_view(state.prefilter_map_view);
    sg_destroy_image(state.prefilter_map);
    sg_destroy_view(state.irradiance_map_view);
    sg_destroy_image(state.irradiance_map);
    sg_destroy_view(state.hdr_environment_view);
    sg_destroy_image(state.hdr_environment);
    
    // Clean up default textures
    sg_destroy_view(state.default_metallic_roughness_view);
    sg_destroy_image(state.default_metallic_roughness);
    sg_destroy_view(state.default_normal_view);
    sg_destroy_image(state.default_normal);
    sg_destroy_view(state.default_texture_view);
    sg_destroy_image(state.default_texture);
    
    // Clean up pipelines
    sg_destroy_sampler(state.smp);
    sg_destroy_pipeline(state.skybox_pip);
    sg_destroy_pipeline(state.toon_pip);
    sg_destroy_pipeline(state.pbr_pip);
    sg_destroy_pipeline(state.pip);
    
    sg_shutdown();
}

static void event(const sapp_event* ev) {
    switch (ev->type) {
        case SAPP_EVENTTYPE_MOUSE_DOWN:
            if (ev->mouse_button == SAPP_MOUSEBUTTON_LEFT) {
                state.mouse_down = true;
                state.last_mouse_x = ev->mouse_x;
                state.last_mouse_y = ev->mouse_y;
            }
            break;
            
        case SAPP_EVENTTYPE_MOUSE_UP:
            if (ev->mouse_button == SAPP_MOUSEBUTTON_LEFT) {
                state.mouse_down = false;
            }
            break;
            
        case SAPP_EVENTTYPE_MOUSE_MOVE:
            if (state.mouse_down) {
                float dx = ev->mouse_x - state.last_mouse_x;
                float dy = ev->mouse_y - state.last_mouse_y;
                
                state.cam_azimuth -= dx * 0.001f;
                state.cam_elevation += dy * 0.001f;
                
                // Clamp elevation
                state.cam_elevation = HMM_Clamp(-89.0f, state.cam_elevation, 89.0f);
                
                state.last_mouse_x = ev->mouse_x;
                state.last_mouse_y = ev->mouse_y;
            }
            break;
            
        case SAPP_EVENTTYPE_MOUSE_SCROLL:
            state.cam_distance -= ev->scroll_y * state.cam_distance * 0.1f;
            state.cam_distance = HMM_MAX(0.1f, state.cam_distance);
            break;
            
        case SAPP_EVENTTYPE_FILES_DROPPED: {
            int num_files = sapp_get_num_dropped_files();
            if (num_files > 0) {
                const char* filepath = sapp_get_dropped_file_path(0);
                load_model(filepath);
            }
            break;
        }
        
        case SAPP_EVENTTYPE_KEY_DOWN:
            if (ev->key_code == SAPP_KEYCODE_ESCAPE) {
                sapp_request_quit();
            } else if (ev->key_code == SAPP_KEYCODE_R) {
                // Reset camera
                if (state.model_loaded) {
                    state.cam_target = state.model.center;
                    state.cam_distance = state.model.radius * 2.5f;
                    state.cam_elevation = 15.0f;
                    state.cam_azimuth = 45.0f;
                }
            } else if (ev->key_code == SAPP_KEYCODE_S) {
                // Toggle skybox
                state.show_skybox = !state.show_skybox;
            } else if (ev->key_code == SAPP_KEYCODE_EQUAL || ev->key_code == SAPP_KEYCODE_KP_ADD) {
                // Increase exposure
                state.skybox_exposure = HMM_MIN(state.skybox_exposure + 0.1f, 5.0f);
            } else if (ev->key_code == SAPP_KEYCODE_MINUS || ev->key_code == SAPP_KEYCODE_KP_SUBTRACT) {
                // Decrease exposure
                state.skybox_exposure = HMM_MAX(state.skybox_exposure - 0.1f, 0.1f);
            } else if (ev->key_code == SAPP_KEYCODE_LEFT_BRACKET) {
                // Decrease LOD
                state.skybox_lod = HMM_MAX(state.skybox_lod - 0.5f, 0.0f);
            } else if (ev->key_code == SAPP_KEYCODE_RIGHT_BRACKET) {
                // Increase LOD
                state.skybox_lod = HMM_MIN(state.skybox_lod + 0.5f, 4.0f);
            }
            break;
            
        default:
            break;
    }
}

sapp_desc sokol_main(int argc, char* argv[]) {
    sapp_desc desc = {};
    desc.init_cb = init;
    desc.frame_cb = frame;
    desc.cleanup_cb = cleanup;
    desc.event_cb = event;
    desc.width = 1280;
    desc.height = 720;
    desc.window_title = "VRM/GLTF/GLB Viewer";
    desc.icon.sokol_default = true;
    desc.enable_dragndrop = true;
    desc.max_dropped_files = 1;
    desc.logger.func = slog_func;
    desc.high_dpi = true;
    // desc.win32.console_create = true;
    
    return desc;
}
