// VRM/GLTF/GLB Viewer using Sokol
// A simple 3D model viewer for VRM, GLTF, and GLB files

#define HANDMADE_MATH_USE_DEGREES
#include "HandmadeMath.h"

#define SOKOL_IMPL
#include "sokol_app.h"
#include "sokol_gfx.h"
#include "sokol_log.h"
#include "sokol_glue.h"

#define CGLTF_IMPLEMENTATION
#include "cgltf/cgltf.h"

#include "nlohmann/json.hpp"

#define USE_VRMC_VRM_0_0
#define USE_VRMC_VRM_1_0
#include <VRMC/VRM.h>

#define STB_IMAGE_IMPLEMENTATION
#define STBI_WINDOWS_UTF8
#include "stb_image.h"

#include <vector>
#include <string>
#include <cstdio>
#include <cmath>

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#endif

// ============================================================================
// Shader (generated by sokol-shdc)
// ============================================================================
#include "shader/mesh.glsl.h"

// ============================================================================
// Mesh structure for rendering
// ============================================================================

struct Vertex {
    float pos[3];
    float normal[3];
    float uv[2];
};

struct RenderMesh {
    sg_buffer vertex_buffer;
    sg_buffer index_buffer;
    int num_indices;
    sg_image texture;
    sg_view texture_view;  // View object for texture binding
    HMM_Vec4 base_color;
    bool has_indices;
    int num_vertices;
};

struct Model {
    std::vector<RenderMesh> meshes;
    HMM_Vec3 center;
    float radius;
};

// ============================================================================
// Global state
// ============================================================================

static struct {
    sg_pipeline pip;
    sg_sampler smp;
    sg_image default_texture;
    sg_view default_texture_view;  // View for default texture
    Model model;
    bool model_loaded;
    
    // Camera
    float cam_distance;
    float cam_azimuth;
    float cam_elevation;
    HMM_Vec3 cam_target;
    
    // Input
    bool mouse_down;
    float last_mouse_x;
    float last_mouse_y;
    
    // Animation
    float time;
} state;

// ============================================================================
// Helper functions
// ============================================================================

static void log_message(const char* msg) {
    printf("[VRM Viewer] %s\n", msg);
}

// ============================================================================
// UTF-8 file reading support for Windows
// ============================================================================

#ifdef _WIN32
static std::wstring utf8_to_wstring(const char* utf8_str) {
    if (!utf8_str || !*utf8_str) return L"";
    int len = MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, nullptr, 0);
    if (len <= 0) return L"";
    std::wstring result(len - 1, L'\0');
    MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, &result[0], len);
    return result;
}

static bool read_file_utf8(const char* filepath, std::vector<uint8_t>& out_data) {
    std::wstring wpath = utf8_to_wstring(filepath);
    HANDLE hFile = CreateFileW(wpath.c_str(), GENERIC_READ, FILE_SHARE_READ, 
                               nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hFile == INVALID_HANDLE_VALUE) {
        return false;
    }
    
    LARGE_INTEGER fileSize;
    if (!GetFileSizeEx(hFile, &fileSize)) {
        CloseHandle(hFile);
        return false;
    }
    
    out_data.resize((size_t)fileSize.QuadPart);
    DWORD bytesRead;
    BOOL success = ReadFile(hFile, out_data.data(), (DWORD)fileSize.QuadPart, &bytesRead, nullptr);
    CloseHandle(hFile);
    
    return success && bytesRead == fileSize.QuadPart;
}

static FILE* fopen_utf8(const char* filepath, const char* mode) {
    std::wstring wpath = utf8_to_wstring(filepath);
    std::wstring wmode = utf8_to_wstring(mode);
    return _wfopen(wpath.c_str(), wmode.c_str());
}
#else
static bool read_file_utf8(const char* filepath, std::vector<uint8_t>& out_data) {
    FILE* f = fopen(filepath, "rb");
    if (!f) return false;
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    out_data.resize(size);
    size_t read = fread(out_data.data(), 1, size, f);
    fclose(f);
    
    return read == (size_t)size;
}

static FILE* fopen_utf8(const char* filepath, const char* mode) {
    return fopen(filepath, mode);
}
#endif

static sg_view create_texture_view(sg_image img) {
    sg_view_desc view_desc = {};
    view_desc.texture.image = img;
    return sg_make_view(&view_desc);
}

static sg_image create_default_white_texture() {
    uint32_t pixels[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
    sg_image_desc desc = {};
    desc.width = 2;
    desc.height = 2;
    desc.data.mip_levels[0] = { pixels, sizeof(pixels) };
    desc.label = "default-texture";
    return sg_make_image(&desc);
}

static sg_image load_texture_from_buffer(const uint8_t* data, size_t size) {
    int width, height, channels;
    stbi_set_flip_vertically_on_load(0);
    uint8_t* pixels = stbi_load_from_memory(data, (int)size, &width, &height, &channels, 4);
    if (!pixels) {
        log_message("Failed to load texture from buffer");
        return state.default_texture;
    }
    
    sg_image_desc desc = {};
    desc.width = width;
    desc.height = height;
    desc.data.mip_levels[0] = { pixels, (size_t)(width * height * 4) };
    sg_image img = sg_make_image(&desc);
    
    stbi_image_free(pixels);
    return img;
}

static sg_image load_texture_from_file(const char* base_path, const char* uri) {
    // Build full path
    std::string path = base_path;
    size_t last_slash = path.find_last_of("/\\");
    if (last_slash != std::string::npos) {
        path = path.substr(0, last_slash + 1);
    } else {
        path = "";
    }
    path += uri;
    
    // Read file with UTF-8 support
    std::vector<uint8_t> file_data;
    if (!read_file_utf8(path.c_str(), file_data)) {
        log_message(("Failed to read texture file: " + path).c_str());
        return state.default_texture;
    }
    
    int width, height, channels;
    stbi_set_flip_vertically_on_load(0);
    uint8_t* pixels = stbi_load_from_memory(file_data.data(), (int)file_data.size(), &width, &height, &channels, 4);
    if (!pixels) {
        log_message(("Failed to decode texture: " + path).c_str());
        return state.default_texture;
    }
    
    sg_image_desc desc = {};
    desc.width = width;
    desc.height = height;
    desc.data.mip_levels[0] = { pixels, (size_t)(width * height * 4) };
    sg_image img = sg_make_image(&desc);
    
    stbi_image_free(pixels);
    log_message(("Loaded texture: " + path).c_str());
    return img;
}

// ============================================================================
// GLTF/GLB/VRM Loading
// ============================================================================

// Custom cgltf file read callback for UTF-8 path support
static cgltf_result cgltf_read_file_utf8(const cgltf_memory_options* memory_options, 
                                          const cgltf_file_options* file_options,
                                          const char* path, cgltf_size* size, void** data) {
    (void)file_options;
    
    std::vector<uint8_t> file_data;
    if (!read_file_utf8(path, file_data)) {
        return cgltf_result_file_not_found;
    }
    
    void* (*memory_alloc)(void*, cgltf_size) = memory_options->alloc ? memory_options->alloc : &cgltf_default_alloc;
    void* result = memory_alloc(memory_options->user_data, file_data.size());
    if (!result) {
        return cgltf_result_out_of_memory;
    }
    
    memcpy(result, file_data.data(), file_data.size());
    *size = file_data.size();
    *data = result;
    
    return cgltf_result_success;
}

static void cgltf_release_file_utf8(const cgltf_memory_options* memory_options,
                                     const cgltf_file_options* file_options, void* data) {
    (void)file_options;
    void (*memory_free)(void*, void*) = memory_options->free ? memory_options->free : &cgltf_default_free;
    memory_free(memory_options->user_data, data);
}

static bool load_model(const char* filepath) {
    log_message(("Loading model: " + std::string(filepath)).c_str());
    
    // Read file with UTF-8 support
    std::vector<uint8_t> file_data;
    if (!read_file_utf8(filepath, file_data)) {
        log_message("Failed to read model file");
        return false;
    }
    
    cgltf_options options = {};
    options.file.read = cgltf_read_file_utf8;
    options.file.release = cgltf_release_file_utf8;
    
    cgltf_data* data = nullptr;
    
    // Parse from memory
    cgltf_result result = cgltf_parse(&options, file_data.data(), file_data.size(), &data);
    if (result != cgltf_result_success) {
        log_message("Failed to parse GLTF file");
        return false;
    }
    
    // Load buffers (uses our custom file read callback for external files)
    result = cgltf_load_buffers(&options, data, filepath);
    if (result != cgltf_result_success) {
        log_message("Failed to load GLTF buffers");
        cgltf_free(data);
        return false;
    }
    
    // Clear existing model
    for (auto& mesh : state.model.meshes) {
        sg_destroy_buffer(mesh.vertex_buffer);
        if (mesh.has_indices) {
            sg_destroy_buffer(mesh.index_buffer);
        }
        if (mesh.texture.id != state.default_texture.id) {
            sg_destroy_view(mesh.texture_view);
            sg_destroy_image(mesh.texture);
        }
    }
    state.model.meshes.clear();
    
    // Calculate bounding box for camera positioning
    HMM_Vec3 min_bounds = HMM_V3(1e10f, 1e10f, 1e10f);
    HMM_Vec3 max_bounds = HMM_V3(-1e10f, -1e10f, -1e10f);
    
    // Load textures
    std::vector<sg_image> textures(data->images_count, state.default_texture);
    std::vector<sg_view> texture_views(data->images_count, state.default_texture_view);
    for (size_t i = 0; i < data->images_count; i++) {
        cgltf_image* image = &data->images[i];
        
        if (image->buffer_view) {
            // Embedded texture
            const uint8_t* buffer_data = (const uint8_t*)image->buffer_view->buffer->data;
            buffer_data += image->buffer_view->offset;
            textures[i] = load_texture_from_buffer(buffer_data, image->buffer_view->size);
        } else if (image->uri) {
            // External texture file
            textures[i] = load_texture_from_file(filepath, image->uri);
        }
        
        // Create view for texture if it's not the default
        if (textures[i].id != state.default_texture.id) {
            texture_views[i] = create_texture_view(textures[i]);
        }
    }
    
    // Process all meshes in all nodes
    for (size_t ni = 0; ni < data->nodes_count; ni++) {
        cgltf_node* node = &data->nodes[ni];
        if (!node->mesh) continue;
        
        // Get node transform
        float node_matrix[16];
        cgltf_node_transform_world(node, node_matrix);
        
        cgltf_mesh* mesh = node->mesh;
        
        for (size_t pi = 0; pi < mesh->primitives_count; pi++) {
            cgltf_primitive* prim = &mesh->primitives[pi];
            
            if (prim->type != cgltf_primitive_type_triangles) {
                continue;
            }
            
            // Find position, normal, and texcoord accessors
            cgltf_accessor* pos_accessor = nullptr;
            cgltf_accessor* norm_accessor = nullptr;
            cgltf_accessor* uv_accessor = nullptr;
            
            for (size_t ai = 0; ai < prim->attributes_count; ai++) {
                cgltf_attribute* attr = &prim->attributes[ai];
                switch (attr->type) {
                    case cgltf_attribute_type_position:
                        pos_accessor = attr->data;
                        break;
                    case cgltf_attribute_type_normal:
                        norm_accessor = attr->data;
                        break;
                    case cgltf_attribute_type_texcoord:
                        if (attr->index == 0) {
                            uv_accessor = attr->data;
                        }
                        break;
                    default:
                        break;
                }
            }
            
            if (!pos_accessor) {
                continue;
            }
            
            size_t vertex_count = pos_accessor->count;
            std::vector<Vertex> vertices(vertex_count);
            
            // Read positions
            for (size_t vi = 0; vi < vertex_count; vi++) {
                float pos[3] = {0, 0, 0};
                cgltf_accessor_read_float(pos_accessor, vi, pos, 3);
                
                // Apply node transform
                float tx = node_matrix[0]*pos[0] + node_matrix[4]*pos[1] + node_matrix[8]*pos[2] + node_matrix[12];
                float ty = node_matrix[1]*pos[0] + node_matrix[5]*pos[1] + node_matrix[9]*pos[2] + node_matrix[13];
                float tz = node_matrix[2]*pos[0] + node_matrix[6]*pos[1] + node_matrix[10]*pos[2] + node_matrix[14];
                
                vertices[vi].pos[0] = tx;
                vertices[vi].pos[1] = ty;
                vertices[vi].pos[2] = tz;
                
                // Update bounds
                min_bounds.X = HMM_MIN(min_bounds.X, tx);
                min_bounds.Y = HMM_MIN(min_bounds.Y, ty);
                min_bounds.Z = HMM_MIN(min_bounds.Z, tz);
                max_bounds.X = HMM_MAX(max_bounds.X, tx);
                max_bounds.Y = HMM_MAX(max_bounds.Y, ty);
                max_bounds.Z = HMM_MAX(max_bounds.Z, tz);
            }
            
            // Read normals
            if (norm_accessor) {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    float norm[3] = {0, 1, 0};
                    cgltf_accessor_read_float(norm_accessor, vi, norm, 3);
                    
                    // Apply node rotation (ignore scale for normals)
                    float nx = node_matrix[0]*norm[0] + node_matrix[4]*norm[1] + node_matrix[8]*norm[2];
                    float ny = node_matrix[1]*norm[0] + node_matrix[5]*norm[1] + node_matrix[9]*norm[2];
                    float nz = node_matrix[2]*norm[0] + node_matrix[6]*norm[1] + node_matrix[10]*norm[2];
                    float len = sqrtf(nx*nx + ny*ny + nz*nz);
                    if (len > 0.0001f) {
                        vertices[vi].normal[0] = nx / len;
                        vertices[vi].normal[1] = ny / len;
                        vertices[vi].normal[2] = nz / len;
                    } else {
                        vertices[vi].normal[0] = 0;
                        vertices[vi].normal[1] = 1;
                        vertices[vi].normal[2] = 0;
                    }
                }
            } else {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    vertices[vi].normal[0] = 0;
                    vertices[vi].normal[1] = 1;
                    vertices[vi].normal[2] = 0;
                }
            }
            
            // Read UVs
            if (uv_accessor) {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    float uv[2] = {0, 0};
                    cgltf_accessor_read_float(uv_accessor, vi, uv, 2);
                    vertices[vi].uv[0] = uv[0];
                    vertices[vi].uv[1] = uv[1];
                }
            } else {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    vertices[vi].uv[0] = 0;
                    vertices[vi].uv[1] = 0;
                }
            }
            
            // Create render mesh
            RenderMesh render_mesh = {};
            
            // Create vertex buffer
            sg_buffer_desc vbuf_desc = {};
            vbuf_desc.data = { vertices.data(), vertices.size() * sizeof(Vertex) };
            vbuf_desc.label = "mesh-vertices";
            render_mesh.vertex_buffer = sg_make_buffer(&vbuf_desc);
            render_mesh.num_vertices = (int)vertex_count;
            
            // Read indices if available
            if (prim->indices) {
                size_t index_count = prim->indices->count;
                std::vector<uint32_t> indices(index_count);
                
                for (size_t ii = 0; ii < index_count; ii++) {
                    indices[ii] = (uint32_t)cgltf_accessor_read_index(prim->indices, ii);
                }
                
                sg_buffer_desc ibuf_desc = {};
                ibuf_desc.usage.index_buffer = true;
                ibuf_desc.data = { indices.data(), indices.size() * sizeof(uint32_t) };
                ibuf_desc.label = "mesh-indices";
                render_mesh.index_buffer = sg_make_buffer(&ibuf_desc);
                render_mesh.num_indices = (int)index_count;
                render_mesh.has_indices = true;
            } else {
                render_mesh.has_indices = false;
            }
            
            // Get material
            render_mesh.base_color = HMM_V4(1.0f, 1.0f, 1.0f, 1.0f);
            render_mesh.texture = state.default_texture;
            render_mesh.texture_view = state.default_texture_view;
            
            if (prim->material) {
                cgltf_material* mat = prim->material;
                
                if (mat->has_pbr_metallic_roughness) {
                    cgltf_pbr_metallic_roughness* pbr = &mat->pbr_metallic_roughness;
                    render_mesh.base_color = HMM_V4(
                        pbr->base_color_factor[0],
                        pbr->base_color_factor[1],
                        pbr->base_color_factor[2],
                        pbr->base_color_factor[3]
                    );
                    
                    if (pbr->base_color_texture.texture) {
                        cgltf_texture* tex = pbr->base_color_texture.texture;
                        if (tex->image) {
                            size_t img_idx = tex->image - data->images;
                            if (img_idx < textures.size()) {
                                render_mesh.texture = textures[img_idx];
                                render_mesh.texture_view = texture_views[img_idx];
                            }
                        }
                    }
                }
            }
            
            state.model.meshes.push_back(render_mesh);
        }
    }
    
    cgltf_free(data);
    
    // Calculate model center and radius
    state.model.center = HMM_MulV3F(HMM_AddV3(min_bounds, max_bounds), 0.5f);
    HMM_Vec3 extent = HMM_SubV3(max_bounds, min_bounds);
    state.model.radius = HMM_LenV3(extent) * 0.5f;
    
    if (state.model.radius < 0.001f) {
        state.model.radius = 1.0f;
    }
    
    // Set up camera to view the model
    state.cam_target = state.model.center;
    state.cam_distance = state.model.radius * 2.5f;
    state.cam_elevation = 15.0f;
    state.cam_azimuth = 45.0f;
    
    log_message(("Loaded " + std::to_string(state.model.meshes.size()) + " mesh(es)").c_str());
    state.model_loaded = true;
    
    return true;
}

// ============================================================================
// Sokol callbacks
// ============================================================================

static void init() {
    log_message("Initializing...");
    
    // Setup sokol-gfx
    sg_desc desc = {};
    desc.environment = sglue_environment();
    desc.logger.func = slog_func;
    sg_setup(&desc);
    
    // Create default texture and its view
    state.default_texture = create_default_white_texture();
    state.default_texture_view = create_texture_view(state.default_texture);
    
    // Create sampler
    sg_sampler_desc smp_desc = {};
    smp_desc.min_filter = SG_FILTER_LINEAR;
    smp_desc.mag_filter = SG_FILTER_LINEAR;
    smp_desc.wrap_u = SG_WRAP_REPEAT;
    smp_desc.wrap_v = SG_WRAP_REPEAT;
    state.smp = sg_make_sampler(&smp_desc);
    
    // Create shader using sokol-shdc generated descriptor
    sg_shader shd = sg_make_shader(mesh_shader_desc(sg_query_backend()));
    
    // Create pipeline
    sg_pipeline_desc pip_desc = {};
    pip_desc.shader = shd;
    pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT3;  // position
    pip_desc.layout.attrs[1].format = SG_VERTEXFORMAT_FLOAT3;  // normal
    pip_desc.layout.attrs[2].format = SG_VERTEXFORMAT_FLOAT2;  // uv
    pip_desc.index_type = SG_INDEXTYPE_UINT32;
    // pip_desc.cull_mode = SG_CULLMODE_BACK;
    pip_desc.cull_mode = SG_CULLMODE_NONE;
    pip_desc.depth.write_enabled = true;
    pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    pip_desc.label = "mesh-pipeline";
    state.pip = sg_make_pipeline(&pip_desc);
    
    // Initialize camera
    state.cam_distance = 5.0f;
    state.cam_azimuth = 45.0f;
    state.cam_elevation = 20.0f;
    state.cam_target = HMM_V3(0, 0, 0);
    
    state.mouse_down = false;
    state.time = 0.0f;
    state.model_loaded = false;
    
    // Try to load a default model if command line argument provided
    // For now, we'll just show an empty scene
    log_message("Ready. Drag and drop a VRM/GLTF/GLB file to load.");
}

static void frame() {
    state.time += (float)sapp_frame_duration();
    
    // Calculate camera position
    float azimuth_rad = HMM_AngleRad(state.cam_azimuth);
    float elevation_rad = HMM_AngleRad(state.cam_elevation);
    
    float cos_elev = cosf(elevation_rad);
    float sin_elev = sinf(elevation_rad);
    float cos_azim = cosf(azimuth_rad);
    float sin_azim = sinf(azimuth_rad);
    
    HMM_Vec3 cam_offset = HMM_V3(
        cos_elev * sin_azim * state.cam_distance,
        sin_elev * state.cam_distance,
        cos_elev * cos_azim * state.cam_distance
    );
    HMM_Vec3 cam_pos = HMM_AddV3(state.cam_target, cam_offset);
    
    // Build view and projection matrices
    float aspect = sapp_widthf() / sapp_heightf();
    HMM_Mat4 proj = HMM_Perspective_RH_ZO(45.0f, aspect, 0.01f, 1000.0f);
    HMM_Mat4 view = HMM_LookAt_RH(cam_pos, state.cam_target, HMM_V3(0, 1, 0));
    HMM_Mat4 model = HMM_M4D(1.0f);
    HMM_Mat4 mvp = HMM_MulM4(proj, HMM_MulM4(view, model));
    
    // Light direction (from camera towards scene)
    HMM_Vec3 light_dir = HMM_NormV3(HMM_V3(0.5f, 1.0f, 0.3f));
    
    // Begin pass
    sg_pass pass = {};
    pass.swapchain = sglue_swapchain();
    pass.action.colors[0].load_action = SG_LOADACTION_CLEAR;
    pass.action.colors[0].clear_value = { 0.15f, 0.15f, 0.18f, 1.0f };
    pass.action.depth.load_action = SG_LOADACTION_CLEAR;
    pass.action.depth.clear_value = 1.0f;
    sg_begin_pass(&pass);
    
    if (state.model_loaded) {
        sg_apply_pipeline(state.pip);
        
        for (auto& mesh : state.model.meshes) {
            // Set up bindings
            sg_bindings bind = {};
            bind.vertex_buffers[0] = mesh.vertex_buffer;
            if (mesh.has_indices) {
                bind.index_buffer = mesh.index_buffer;
            }
            bind.views[VIEW_tex] = mesh.texture_view;
            bind.samplers[SMP_smp] = state.smp;
            sg_apply_bindings(&bind);
            
            // Set up vertex shader uniforms
            vs_params_t vs_uniforms = {};
            vs_uniforms.mvp = mvp;
            vs_uniforms.model = model;
            vs_uniforms.light_dir = light_dir;
            sg_apply_uniforms(UB_vs_params, SG_RANGE(vs_uniforms));
            
            // Set up fragment shader uniforms
            fs_params_t fs_uniforms = {};
            fs_uniforms.base_color = mesh.base_color;
            fs_uniforms.light_dir = light_dir;
            fs_uniforms.ambient = HMM_V3(0.3f, 0.3f, 0.35f);
            sg_apply_uniforms(UB_fs_params, SG_RANGE(fs_uniforms));
            
            // Draw
            if (mesh.has_indices) {
                sg_draw(0, mesh.num_indices, 1);
            } else {
                sg_draw(0, mesh.num_vertices, 1);
            }
        }
    }
    
    sg_end_pass();
    sg_commit();
}

static void cleanup() {
    log_message("Cleaning up...");
    
    // Clean up model resources
    for (auto& mesh : state.model.meshes) {
        sg_destroy_buffer(mesh.vertex_buffer);
        if (mesh.has_indices) {
            sg_destroy_buffer(mesh.index_buffer);
        }
        if (mesh.texture.id != state.default_texture.id) {
            sg_destroy_view(mesh.texture_view);
            sg_destroy_image(mesh.texture);
        }
    }
    
    sg_destroy_view(state.default_texture_view);
    sg_destroy_image(state.default_texture);
    sg_destroy_sampler(state.smp);
    sg_destroy_pipeline(state.pip);
    
    sg_shutdown();
}

static void event(const sapp_event* ev) {
    switch (ev->type) {
        case SAPP_EVENTTYPE_MOUSE_DOWN:
            if (ev->mouse_button == SAPP_MOUSEBUTTON_LEFT) {
                state.mouse_down = true;
                state.last_mouse_x = ev->mouse_x;
                state.last_mouse_y = ev->mouse_y;
            }
            break;
            
        case SAPP_EVENTTYPE_MOUSE_UP:
            if (ev->mouse_button == SAPP_MOUSEBUTTON_LEFT) {
                state.mouse_down = false;
            }
            break;
            
        case SAPP_EVENTTYPE_MOUSE_MOVE:
            if (state.mouse_down) {
                float dx = ev->mouse_x - state.last_mouse_x;
                float dy = ev->mouse_y - state.last_mouse_y;
                
                state.cam_azimuth -= dx * 0.001f;
                state.cam_elevation += dy * 0.001f;
                
                // Clamp elevation
                state.cam_elevation = HMM_Clamp(-89.0f, state.cam_elevation, 89.0f);
                
                state.last_mouse_x = ev->mouse_x;
                state.last_mouse_y = ev->mouse_y;
            }
            break;
            
        case SAPP_EVENTTYPE_MOUSE_SCROLL:
            state.cam_distance -= ev->scroll_y * state.cam_distance * 0.1f;
            state.cam_distance = HMM_MAX(0.1f, state.cam_distance);
            break;
            
        case SAPP_EVENTTYPE_FILES_DROPPED: {
            int num_files = sapp_get_num_dropped_files();
            if (num_files > 0) {
                const char* filepath = sapp_get_dropped_file_path(0);
                load_model(filepath);
            }
            break;
        }
        
        case SAPP_EVENTTYPE_KEY_DOWN:
            if (ev->key_code == SAPP_KEYCODE_ESCAPE) {
                sapp_request_quit();
            } else if (ev->key_code == SAPP_KEYCODE_R) {
                // Reset camera
                if (state.model_loaded) {
                    state.cam_target = state.model.center;
                    state.cam_distance = state.model.radius * 2.5f;
                    state.cam_elevation = 15.0f;
                    state.cam_azimuth = 45.0f;
                }
            }
            break;
            
        default:
            break;
    }
}

sapp_desc sokol_main(int argc, char* argv[]) {
    sapp_desc desc = {};
    desc.init_cb = init;
    desc.frame_cb = frame;
    desc.cleanup_cb = cleanup;
    desc.event_cb = event;
    desc.width = 1280;
    desc.height = 720;
    desc.window_title = "VRM/GLTF/GLB Viewer";
    desc.icon.sokol_default = true;
    desc.enable_dragndrop = true;
    desc.max_dropped_files = 1;
    desc.logger.func = slog_func;
    desc.high_dpi = true;
    
    return desc;
}
