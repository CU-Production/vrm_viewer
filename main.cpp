// VRM/GLTF/GLB Viewer using Sokol
// A simple 3D model viewer for VRM, GLTF, and GLB files

#define HANDMADE_MATH_USE_DEGREES
#include "HandmadeMath.h"

#include "sokol_app.h"
#include "sokol_gfx.h"
#include "sokol_log.h"
#include "sokol_glue.h"

// GUI (Clay-based, compiled as C)
#include "gui.h"

#define CGLTF_IMPLEMENTATION
#include "cgltf/cgltf.h"

#include "nlohmann/json.hpp"

#define USE_VRMC_VRM_0_0
#define USE_VRMC_VRM_1_0
#include <VRMC/VRM.h>

#define STBI_WINDOWS_UTF8
#include "stb_image.h"

#include <vector>
#include <string>
#include <cstdio>
#include <cmath>
#include <random>
#include <thread>
#include "parallel-util.hpp"

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#endif

// ============================================================================
// Shader (generated by sokol-shdc)
// ============================================================================
#include "shader/mesh.glsl.h"
#include "shader/pbr.glsl.h"
#include "shader/skybox.glsl.h"
#include "shader/toon.glsl.h"

// ============================================================================
// Mesh structure for rendering
// ============================================================================

struct Vertex {
    float pos[3];
    float normal[3];
    float uv[2];
    float tangent[4];  // xyz = tangent, w = sign for bitangent
};

struct PBRMaterial {
    sg_image base_color_tex;
    sg_view base_color_view;
    sg_image metallic_roughness_tex;
    sg_view metallic_roughness_view;
    sg_image normal_tex;
    sg_view normal_view;
    sg_image occlusion_tex;
    sg_view occlusion_view;
    sg_image emissive_tex;
    sg_view emissive_view;
    
    HMM_Vec4 base_color_factor;
    float metallic_factor;
    float roughness_factor;
    HMM_Vec3 emissive_factor;
    
    bool is_vrm;  // Use toon shader for VRM models
    float toon_ramp_steps;
    float toon_rim_power;
    float toon_rim_strength;
};

struct RenderMesh {
    sg_buffer vertex_buffer;
    sg_buffer index_buffer;
    int num_indices;
    bool has_indices;
    int num_vertices;
    PBRMaterial material;
};

struct Model {
    std::vector<RenderMesh> meshes;
    HMM_Vec3 center;
    float radius;
};

// ============================================================================
// Global state
// ============================================================================

static struct {
    // Old simple pipeline
    sg_pipeline pip;
    sg_sampler smp;
    
    // PBR pipelines
    sg_pipeline pbr_pip;
    sg_pipeline toon_pip;
    sg_pipeline skybox_pip;
    
    // Default textures
    sg_image default_texture;
    sg_view default_texture_view;
    sg_image default_normal;
    sg_view default_normal_view;
    sg_image default_metallic_roughness;
    sg_view default_metallic_roughness_view;
    
    // IBL resources
    sg_image hdr_environment;
    sg_view hdr_environment_view;
    sg_image irradiance_map;
    sg_view irradiance_map_view;
    sg_image prefilter_map;
    sg_view prefilter_map_view;
    sg_image brdf_lut;
    sg_view brdf_lut_view;
    
    // Skybox
    sg_buffer skybox_vertex_buffer;
    sg_buffer skybox_index_buffer;
    
    Model model;
    bool model_loaded;
    bool is_vrm_model;
    
    // Camera
    float cam_distance;
    float cam_azimuth;
    float cam_elevation;
    HMM_Vec3 cam_target;
    
    // Input
    bool mouse_down;
    float last_mouse_x;
    float last_mouse_y;
    
    // Animation
    float time;
    
    // Skybox settings
    float skybox_lod;
    float skybox_exposure;
    bool show_skybox;
    
    // GUI
    bool show_gui;
    bool gui_hovered;  // True when mouse is over GUI
    
    // Toon shader parameters (adjustable via GUI)
    float toon_light_intensity;
    float toon_shade_toony;
    float toon_shade_strength;
    float toon_rim_threshold;
    float toon_rim_softness;
    float toon_spec_intensity;
} state;

// ============================================================================
// Helper functions
// ============================================================================

static void log_message(const char* msg) {
    printf("[VRM Viewer] %s\n", msg);
}

// ============================================================================
// UTF-8 file reading support for Windows
// ============================================================================

#ifdef _WIN32
static std::wstring utf8_to_wstring(const char* utf8_str) {
    if (!utf8_str || !*utf8_str) return L"";
    int len = MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, nullptr, 0);
    if (len <= 0) return L"";
    std::wstring result(len - 1, L'\0');
    MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, &result[0], len);
    return result;
}

static bool read_file_utf8(const char* filepath, std::vector<uint8_t>& out_data) {
    std::wstring wpath = utf8_to_wstring(filepath);
    HANDLE hFile = CreateFileW(wpath.c_str(), GENERIC_READ, FILE_SHARE_READ, 
                               nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hFile == INVALID_HANDLE_VALUE) {
        return false;
    }
    
    LARGE_INTEGER fileSize;
    if (!GetFileSizeEx(hFile, &fileSize)) {
        CloseHandle(hFile);
        return false;
    }
    
    out_data.resize((size_t)fileSize.QuadPart);
    DWORD bytesRead;
    BOOL success = ReadFile(hFile, out_data.data(), (DWORD)fileSize.QuadPart, &bytesRead, nullptr);
    CloseHandle(hFile);
    
    return success && bytesRead == fileSize.QuadPart;
}

static FILE* fopen_utf8(const char* filepath, const char* mode) {
    std::wstring wpath = utf8_to_wstring(filepath);
    std::wstring wmode = utf8_to_wstring(mode);
    return _wfopen(wpath.c_str(), wmode.c_str());
}
#else
static bool read_file_utf8(const char* filepath, std::vector<uint8_t>& out_data) {
    FILE* f = fopen(filepath, "rb");
    if (!f) return false;
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    out_data.resize(size);
    size_t read = fread(out_data.data(), 1, size, f);
    fclose(f);
    
    return read == (size_t)size;
}

static FILE* fopen_utf8(const char* filepath, const char* mode) {
    return fopen(filepath, mode);
}
#endif

static sg_view create_texture_view(sg_image img, int num_mips = 1) {
    sg_view_desc view_desc = {};
    view_desc.texture.image = img;
    // For cubemap, slices must be base=0, count=1 (entire cubemap)
    view_desc.texture.slices.base = 0;
    view_desc.texture.slices.count = 1;
    view_desc.texture.mip_levels.base = 0;
    view_desc.texture.mip_levels.count = num_mips;
    return sg_make_view(&view_desc);
}

static sg_image create_default_white_texture() {
    uint32_t pixels[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
    sg_image_desc desc = {};
    desc.width = 2;
    desc.height = 2;
    desc.data.mip_levels[0] = { pixels, sizeof(pixels) };
    desc.label = "default-texture";
    return sg_make_image(&desc);
}

static sg_image load_texture_from_buffer(const uint8_t* data, size_t size) {
    int width, height, channels;
    stbi_set_flip_vertically_on_load(0);
    uint8_t* pixels = stbi_load_from_memory(data, (int)size, &width, &height, &channels, 4);
    if (!pixels) {
        log_message("Failed to load texture from buffer");
        return state.default_texture;
    }
    
    sg_image_desc desc = {};
    desc.width = width;
    desc.height = height;
    desc.data.mip_levels[0] = { pixels, (size_t)(width * height * 4) };
    sg_image img = sg_make_image(&desc);
    
    stbi_image_free(pixels);
    return img;
}

static sg_image load_texture_from_file(const char* base_path, const char* uri) {
    // Build full path
    std::string path = base_path;
    size_t last_slash = path.find_last_of("/\\");
    if (last_slash != std::string::npos) {
        path = path.substr(0, last_slash + 1);
    } else {
        path = "";
    }
    path += uri;
    
    // Read file with UTF-8 support
    std::vector<uint8_t> file_data;
    if (!read_file_utf8(path.c_str(), file_data)) {
        log_message(("Failed to read texture file: " + path).c_str());
        return state.default_texture;
    }
    
    int width, height, channels;
    stbi_set_flip_vertically_on_load(0);
    uint8_t* pixels = stbi_load_from_memory(file_data.data(), (int)file_data.size(), &width, &height, &channels, 4);
    if (!pixels) {
        log_message(("Failed to decode texture: " + path).c_str());
        return state.default_texture;
    }
    
    sg_image_desc desc = {};
    desc.width = width;
    desc.height = height;
    desc.data.mip_levels[0] = { pixels, (size_t)(width * height * 4) };
    sg_image img = sg_make_image(&desc);
    
    stbi_image_free(pixels);
    log_message(("Loaded texture: " + path).c_str());
    return img;
}

// ============================================================================
// HDR Loading and IBL (using HandmadeMath for vector operations)
// ============================================================================

// Sample equirectangular HDR texture with bilinear filtering
// dir: normalized direction vector in world space
static HMM_Vec3 sample_equirectangular(const float* hdr_data, int width, int height, HMM_Vec3 dir) {
    // Convert direction to spherical coordinates
    // theta: polar angle from +Y axis (0 = top, PI = bottom)
    // phi: azimuthal angle around Y axis
    float theta = acosf(HMM_Clamp(-1.0f, dir.Y, 1.0f));  // [0, PI]
    float phi = atan2f(dir.X, -dir.Z);  // [-PI, PI], note: -Z is forward
    
    // Convert to UV coordinates
    float u = (phi + HMM_PI32) / (2.0f * HMM_PI32);  // [0, 1]
    float v = theta / HMM_PI32;  // [0, 1]
    
    // Bilinear filtering with proper wrap/clamp
    float px = u * width - 0.5f;
    float py = v * height - 0.5f;
    
    // Wrap helper for horizontal (longitude wraps around)
    auto wrap_x = [width](int x) -> int {
        return ((x % width) + width) % width;
    };
    
    // Clamp helper for vertical (latitude clamps at poles)
    auto clamp_y = [height](int y) -> int {
        return HMM_Clamp(0, y, height - 1);
    };
    
    int x0 = (int)floorf(px);
    int y0 = (int)floorf(py);
    int x1 = x0 + 1;
    int y1 = y0 + 1;
    
    float fx = px - x0;
    float fy = py - y0;
    
    // Sample 4 pixels with wrap/clamp
    auto sample_pixel = [&](int x, int y) -> HMM_Vec3 {
        int sx = wrap_x(x);
        int sy = clamp_y(y);
        int idx = (sy * width + sx) * 3;
        return HMM_V3(hdr_data[idx], hdr_data[idx + 1], hdr_data[idx + 2]);
    };
    
    HMM_Vec3 c00 = sample_pixel(x0, y0);
    HMM_Vec3 c10 = sample_pixel(x1, y0);
    HMM_Vec3 c01 = sample_pixel(x0, y1);
    HMM_Vec3 c11 = sample_pixel(x1, y1);
    
    // Bilinear interpolation using HMM_LerpV3
    HMM_Vec3 c0 = HMM_LerpV3(c00, fx, c10);
    HMM_Vec3 c1 = HMM_LerpV3(c01, fx, c11);
    return HMM_LerpV3(c0, fy, c1);
}

// Get cubemap face direction from face index and UV coordinates
// UV is in [-1, 1] range, returns normalized direction vector
static HMM_Vec3 get_cubemap_direction(int face, float u, float v) {
    HMM_Vec3 dir;
    switch (face) {
        case 0: dir = HMM_V3( 1.0f, -v, -u); break;  // +X
        case 1: dir = HMM_V3(-1.0f, -v,  u); break;  // -X
        case 2: dir = HMM_V3( u,  1.0f,  v); break;  // +Y
        case 3: dir = HMM_V3( u, -1.0f, -v); break;  // -Y
        case 4: dir = HMM_V3( u, -v,  1.0f); break;  // +Z
        case 5: dir = HMM_V3(-u, -v, -1.0f); break;  // -Z
        default: dir = HMM_V3(0, 0, 1); break;
    }
    return HMM_NormV3(dir);
}

// Build orthonormal tangent space basis from normal vector
static void build_tangent_space(HMM_Vec3 N, HMM_Vec3* T, HMM_Vec3* B) {
    // Choose an up vector that's not parallel to N
    HMM_Vec3 up = (fabsf(N.Y) < 0.999f) ? HMM_V3(0, 1, 0) : HMM_V3(1, 0, 0);
    *B = HMM_NormV3(HMM_Cross(N, up));
    *T = HMM_Cross(*B, N);
}

// Transform tangent space direction to world space
static HMM_Vec3 tangent_to_world(HMM_Vec3 local, HMM_Vec3 T, HMM_Vec3 B, HMM_Vec3 N) {
    return HMM_AddV3(HMM_AddV3(
        HMM_MulV3F(T, local.X),
        HMM_MulV3F(B, local.Y)),
        HMM_MulV3F(N, local.Z));
}

// Reflect vector V around normal N
static HMM_Vec3 reflect(HMM_Vec3 V, HMM_Vec3 N) {
    return HMM_SubV3(HMM_MulV3F(N, 2.0f * HMM_DotV3(V, N)), V);
}

// Convert equirectangular HDR to cubemap
static sg_image equirectangular_to_cubemap(const float* hdr_data, int hdr_width, int hdr_height, int cubemap_size) {
    const int face_size = cubemap_size * cubemap_size * 4;  // RGBA32F per face
    std::vector<float> cubemap_data(face_size * 6);  // 6 faces
    
    parallelutil::parallel_for_2d(6 * cubemap_size, cubemap_size, [&](int face_y, int x) {
        int face = face_y / cubemap_size;
        int y = face_y % cubemap_size;
        float* face_data = cubemap_data.data() + face * face_size;
        
        // Convert pixel coordinates to UV in [-1, 1] range
        float u = (x + 0.5f) / cubemap_size * 2.0f - 1.0f;
        float v = (y + 0.5f) / cubemap_size * 2.0f - 1.0f;
        
        // Get direction and sample HDR
        HMM_Vec3 dir = get_cubemap_direction(face, u, v);
        HMM_Vec3 color = sample_equirectangular(hdr_data, hdr_width, hdr_height, dir);
        
        // Store HDR values
        int idx = (y * cubemap_size + x) * 4;
        face_data[idx + 0] = color.X;
        face_data[idx + 1] = color.Y;
        face_data[idx + 2] = color.Z;
        face_data[idx + 3] = 1.0f;
    });
    
    sg_image_desc desc = {};
    desc.type = SG_IMAGETYPE_CUBE;
    desc.width = cubemap_size;
    desc.height = cubemap_size;
    desc.num_slices = 6;
    desc.pixel_format = SG_PIXELFORMAT_RGBA32F;
    desc.data.mip_levels[0] = { cubemap_data.data(), cubemap_data.size() * sizeof(float) };
    desc.label = "environment-cubemap";
    return sg_make_image(&desc);
}

// Generate irradiance map by convolving the environment cubemap
static sg_image generate_irradiance_map(const float* hdr_data, int hdr_width, int hdr_height, int size) {
    const int face_size = size * size * 4;
    std::vector<float> irradiance_data(face_size * 6);
    
    parallelutil::parallel_for_2d(6 * size, size, [&](int face_y, int x) {
        int face = face_y / size;
        int y = face_y % size;
        float* face_data = irradiance_data.data() + face * face_size;
        
        float u = (x + 0.5f) / size * 2.0f - 1.0f;
        float v = (y + 0.5f) / size * 2.0f - 1.0f;
        
        // Get normal direction for this cubemap pixel
        HMM_Vec3 N = get_cubemap_direction(face, u, v);
        
        // Build tangent space
        HMM_Vec3 T, B;
        build_tangent_space(N, &T, &B);
        
        // Sample hemisphere around normal
        HMM_Vec3 irradiance = HMM_V3(0, 0, 0);
        const int num_samples = 64;
        std::mt19937 rng(static_cast<unsigned int>(face * size * size + y * size + x));
        std::uniform_real_distribution<float> dist(0.0f, 1.0f);
        
        for (int i = 0; i < num_samples; i++) {
            float Xi1 = dist(rng);
            float Xi2 = dist(rng);
            
            // Cosine-weighted hemisphere sampling
            float phi = 2.0f * HMM_PI32 * Xi1;
            float cosTheta = sqrtf(Xi2);
            float sinTheta = sqrtf(1.0f - Xi2);
            
            // Local direction in tangent space
            HMM_Vec3 local_dir = HMM_V3(sinTheta * cosf(phi), sinTheta * sinf(phi), cosTheta);
            
            // Transform to world space
            HMM_Vec3 L = HMM_NormV3(tangent_to_world(local_dir, T, B, N));
            
            // Sample environment and accumulate
            HMM_Vec3 sample_color = sample_equirectangular(hdr_data, hdr_width, hdr_height, L);
            irradiance = HMM_AddV3(irradiance, sample_color);
        }
        
        // Average samples
        irradiance = HMM_MulV3F(irradiance, 1.0f / num_samples);
        
        // Store HDR values
        int idx = (y * size + x) * 4;
        face_data[idx + 0] = irradiance.X;
        face_data[idx + 1] = irradiance.Y;
        face_data[idx + 2] = irradiance.Z;
        face_data[idx + 3] = 1.0f;
    });
    
    sg_image_desc desc = {};
    desc.type = SG_IMAGETYPE_CUBE;
    desc.width = size;
    desc.height = size;
    desc.num_slices = 6;
    desc.pixel_format = SG_PIXELFORMAT_RGBA32F;
    desc.data.mip_levels[0] = { irradiance_data.data(), irradiance_data.size() * sizeof(float) };
    desc.label = "irradiance-map";
    return sg_make_image(&desc);
}

// Generate a single mip level for prefilter map
static void generate_prefilter_mip(const float* hdr_data, int hdr_width, int hdr_height,
                                    float* out_data, int mip_size, float roughness) {
    const int face_size = mip_size * mip_size * 4;
    
    // More samples for rougher surfaces (they need more averaging)
    const int base_samples = 64;
    const int num_samples = base_samples + (int)(roughness * 192);  // 64-256 samples
    
    parallelutil::parallel_for_2d(6 * mip_size, mip_size, [&](int face_y, int x) {
        int face = face_y / mip_size;
        int y = face_y % mip_size;
        float* face_data = out_data + face * face_size;
        
        float u = (x + 0.5f) / mip_size * 2.0f - 1.0f;
        float v = (y + 0.5f) / mip_size * 2.0f - 1.0f;
        
        HMM_Vec3 R = get_cubemap_direction(face, u, v);
        HMM_Vec3 T, B;
        build_tangent_space(R, &T, &B);
        
        // Use roughness^2 for GGX (remapped roughness)
        float a = roughness * roughness;
        float a2 = a * a;
        
        HMM_Vec3 prefiltered = HMM_V3(0, 0, 0);
        float total_weight = 0.0f;
        std::mt19937 rng(static_cast<unsigned int>(face * mip_size * mip_size + y * mip_size + x));
        std::uniform_real_distribution<float> dist(0.0f, 1.0f);
        
        for (int i = 0; i < num_samples; i++) {
            float Xi1 = dist(rng);
            float Xi2 = dist(rng);
            
            // GGX importance sampling
            float phi = 2.0f * HMM_PI32 * Xi1;
            float cosTheta = sqrtf((1.0f - Xi2) / (1.0f + (a2 - 1.0f) * Xi2));
            float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
            
            HMM_Vec3 H_local = HMM_V3(sinTheta * cosf(phi), sinTheta * sinf(phi), cosTheta);
            HMM_Vec3 H = tangent_to_world(H_local, T, B, R);
            HMM_Vec3 L = HMM_NormV3(reflect(R, H));
            
            float NdotL = HMM_MAX(0.0f, HMM_DotV3(R, L));
            if (NdotL > 0.0f) {
                HMM_Vec3 sample_color = sample_equirectangular(hdr_data, hdr_width, hdr_height, L);
                prefiltered = HMM_AddV3(prefiltered, HMM_MulV3F(sample_color, NdotL));
                total_weight += NdotL;
            }
        }
        
        if (total_weight > 0.0f) {
            prefiltered = HMM_MulV3F(prefiltered, 1.0f / total_weight);
        }
        
        int idx = (y * mip_size + x) * 4;
        face_data[idx + 0] = prefiltered.X;
        face_data[idx + 1] = prefiltered.Y;
        face_data[idx + 2] = prefiltered.Z;
        face_data[idx + 3] = 1.0f;
    });
}

// Generate prefilter map with multiple mip levels for different roughness values
static sg_image generate_prefilter_map(const float* hdr_data, int hdr_width, int hdr_height, int base_size) {
    // Calculate number of mip levels (down to 8x8 minimum)
    const int max_mip_levels = 5;  // 128 -> 64 -> 32 -> 16 -> 8
    int num_mips = 0;
    int temp_size = base_size;
    while (temp_size >= 8 && num_mips < max_mip_levels) {
        num_mips++;
        temp_size /= 2;
    }
    
    log_message(("Generating prefilter map with " + std::to_string(num_mips) + " mip levels").c_str());
    
    // Allocate storage for all mip levels
    std::vector<std::vector<float>> mip_data(num_mips);
    
    for (int mip = 0; mip < num_mips; mip++) {
        int mip_size = base_size >> mip;  // base_size / 2^mip
        float roughness = (float)mip / (float)(num_mips - 1);  // 0.0 to 1.0
        
        // Ensure minimum roughness to avoid singularities
        roughness = HMM_MAX(roughness, 0.01f);
        
        log_message(("  Mip " + std::to_string(mip) + ": " + std::to_string(mip_size) + 
                     "x" + std::to_string(mip_size) + ", roughness=" + 
                     std::to_string(roughness)).c_str());
        
        int face_size = mip_size * mip_size * 4;
        mip_data[mip].resize(face_size * 6);
        
        generate_prefilter_mip(hdr_data, hdr_width, hdr_height, 
                               mip_data[mip].data(), mip_size, roughness);
    }
    
    // Create image with all mip levels
    sg_image_desc desc = {};
    desc.type = SG_IMAGETYPE_CUBE;
    desc.width = base_size;
    desc.height = base_size;
    desc.num_slices = 6;
    desc.num_mipmaps = num_mips;
    desc.pixel_format = SG_PIXELFORMAT_RGBA32F;
    
    for (int mip = 0; mip < num_mips; mip++) {
        desc.data.mip_levels[mip] = { mip_data[mip].data(), mip_data[mip].size() * sizeof(float) };
    }
    
    desc.label = "prefilter-map";
    return sg_make_image(&desc);
}

// Generate BRDF LUT (parallelized CPU version)
static sg_image generate_brdf_lut() {
    const int size = 512;
    std::vector<float> lut_data(size * size * 2);
    
    parallelutil::parallel_for_2d(size, size, [&](int x, int y) {
        float NdotV = (x + 0.5f) / size;
        float roughness = (y + 0.5f) / size;
        
        // View vector in tangent space (N = (0,0,1))
        HMM_Vec3 V = HMM_V3(sqrtf(1.0f - NdotV * NdotV), 0.0f, NdotV);
        float A = 0.0f, B = 0.0f;
        
        std::mt19937 rng(static_cast<unsigned int>(x * size + y));
        std::uniform_real_distribution<float> dist(0.0f, 1.0f);
        
        const int num_samples = 1024;
        for (int i = 0; i < num_samples; i++) {
            float Xi1 = dist(rng);
            float Xi2 = dist(rng);
            
            // GGX importance sampling
            float a = roughness * roughness;
            float phi = 2.0f * HMM_PI32 * Xi1;
            float cosTheta = sqrtf((1.0f - Xi2) / (1.0f + (a * a - 1.0f) * Xi2));
            float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
            
            // Half vector in tangent space
            HMM_Vec3 H = HMM_V3(cosf(phi) * sinTheta, sinf(phi) * sinTheta, cosTheta);
            
            float NdotH = H.Z;  // N = (0,0,1) in tangent space
            float VdotH = HMM_DotV3(V, H);
            
            if (NdotH > 0.0f && VdotH > 0.0f) {
                // Simplified geometry term
                float G = HMM_MIN(2.0f * NdotH / VdotH, 1.0f);
                float G_Vis = G * VdotH / (NdotH * NdotV);
                float Fc = powf(HMM_MAX(1.0f - VdotH, 0.0f), 5.0f);
                A += (1.0f - Fc) * G_Vis;
                B += Fc * G_Vis;
            }
        }
        
        lut_data[(y * size + x) * 2 + 0] = A / num_samples;
        lut_data[(y * size + x) * 2 + 1] = B / num_samples;
    });
    
    // Convert to RGBA8 format
    std::vector<uint8_t> rgba_data(size * size * 4);
    for (int i = 0; i < size * size; i++) {
        rgba_data[i * 4 + 0] = (uint8_t)HMM_MIN(lut_data[i * 2 + 0] * 255.0f, 255.0f);
        rgba_data[i * 4 + 1] = (uint8_t)HMM_MIN(lut_data[i * 2 + 1] * 255.0f, 255.0f);
        rgba_data[i * 4 + 2] = 0;
        rgba_data[i * 4 + 3] = 255;
    }
    
    sg_image_desc desc = {};
    desc.width = size;
    desc.height = size;
    desc.data.mip_levels[0] = { rgba_data.data(), rgba_data.size() };
    desc.label = "brdf-lut";
    return sg_make_image(&desc);
}

// Create a simple cubemap placeholder
static sg_image create_simple_cubemap(uint8_t r, uint8_t g, uint8_t b) {
    const int size = 64;
    const int face_size = size * size * 4;  // RGBA32F per face
    std::vector<float> cubemap_data(face_size * 6);  // 6 faces
    
    // Convert uint8 color to float (normalized to 0-1 range, then scale for HDR)
    float rf = (r / 255.0f) * 0.1f;  // Low intensity for placeholder
    float gf = (g / 255.0f) * 0.1f;
    float bf = (b / 255.0f) * 0.1f;
    
    // Fill all 6 faces with the same color
    for (int face = 0; face < 6; face++) {
        float* face_data = cubemap_data.data() + face * face_size;
        for (int i = 0; i < size * size; i++) {
            face_data[i * 4 + 0] = rf;
            face_data[i * 4 + 1] = gf;
            face_data[i * 4 + 2] = bf;
            face_data[i * 4 + 3] = 1.0f;
        }
    }
    
    sg_image_desc desc = {};
    desc.type = SG_IMAGETYPE_CUBE;
    desc.width = size;
    desc.height = size;
    desc.num_slices = 6;  // Required for cubemap
    desc.pixel_format = SG_PIXELFORMAT_RGBA32F;  // Use 32-bit float to preserve HDR range
    // For cubemap, each mip level contains all 6 faces in order: +X, -X, +Y, -Y, +Z, -Z
    desc.data.mip_levels[0] = { cubemap_data.data(), cubemap_data.size() * sizeof(float) };
    desc.label = "simple-cubemap";
    return sg_make_image(&desc);
}

// Create IBL maps from HDR environment
static void create_ibl_maps(const char* hdr_filepath) {
    // Load HDR data
    int hdr_width, hdr_height, hdr_channels;
    stbi_set_flip_vertically_on_load(0);  // Don't flip HDR - standard is V=0 at top
    float* hdr_data = stbi_loadf(hdr_filepath, &hdr_width, &hdr_height, &hdr_channels, 3);
    if (!hdr_data) {
        log_message(("Failed to load HDR for IBL: " + std::string(hdr_filepath)).c_str());
        // Fallback to simple cubemaps
        state.hdr_environment = create_simple_cubemap(128, 128, 128);
        state.hdr_environment_view = create_texture_view(state.hdr_environment);
        state.irradiance_map = create_simple_cubemap(50, 60, 70);
        state.irradiance_map_view = create_texture_view(state.irradiance_map);
        state.prefilter_map = create_simple_cubemap(80, 90, 100);
        state.prefilter_map_view = create_texture_view(state.prefilter_map);
        state.brdf_lut = generate_brdf_lut();
        state.brdf_lut_view = create_texture_view(state.brdf_lut);
        return;
    }
    
    log_message("Generating IBL maps from HDR...");
    
    // Generate environment cubemap for skybox (high resolution, no filtering)
    int environment_size = 512;  // Higher resolution for sharp skybox
    state.hdr_environment = equirectangular_to_cubemap(hdr_data, hdr_width, hdr_height, environment_size);
    state.hdr_environment_view = create_texture_view(state.hdr_environment);
    log_message(("  Environment cubemap: " + std::to_string(environment_size) + "x" + std::to_string(environment_size)).c_str());
    
    // Generate irradiance map (diffuse IBL)
    int irradiance_size = 32;
    state.irradiance_map = generate_irradiance_map(hdr_data, hdr_width, hdr_height, irradiance_size);
    state.irradiance_map_view = create_texture_view(state.irradiance_map);
    log_message(("  Irradiance map: " + std::to_string(irradiance_size) + "x" + std::to_string(irradiance_size)).c_str());
    
    // Generate prefilter map with mip chain for specular IBL
    int prefilter_size = 256;
    int prefilter_mips = 5;  // 256 -> 128 -> 64 -> 32 -> 16 (matches MAX_REFLECTION_LOD in shader)
    state.prefilter_map = generate_prefilter_map(hdr_data, hdr_width, hdr_height, prefilter_size);
    state.prefilter_map_view = create_texture_view(state.prefilter_map, prefilter_mips);
    
    // Generate BRDF LUT
    state.brdf_lut = generate_brdf_lut();
    state.brdf_lut_view = create_texture_view(state.brdf_lut);
    
    stbi_image_free(hdr_data);
    log_message("IBL maps generated successfully");
}

// ============================================================================
// GLTF/GLB/VRM Loading
// ============================================================================

// Custom cgltf file read callback for UTF-8 path support
static cgltf_result cgltf_read_file_utf8(const cgltf_memory_options* memory_options, 
                                          const cgltf_file_options* file_options,
                                          const char* path, cgltf_size* size, void** data) {
    (void)file_options;
    
    std::vector<uint8_t> file_data;
    if (!read_file_utf8(path, file_data)) {
        return cgltf_result_file_not_found;
    }
    
    void* (*memory_alloc)(void*, cgltf_size) = memory_options->alloc ? memory_options->alloc : &cgltf_default_alloc;
    void* result = memory_alloc(memory_options->user_data, file_data.size());
    if (!result) {
        return cgltf_result_out_of_memory;
    }
    
    memcpy(result, file_data.data(), file_data.size());
    *size = file_data.size();
    *data = result;
    
    return cgltf_result_success;
}

static void cgltf_release_file_utf8(const cgltf_memory_options* memory_options,
                                     const cgltf_file_options* file_options, void* data) {
    (void)file_options;
    void (*memory_free)(void*, void*) = memory_options->free ? memory_options->free : &cgltf_default_free;
    memory_free(memory_options->user_data, data);
}

static bool load_model(const char* filepath) {
    log_message(("Loading model: " + std::string(filepath)).c_str());
    
    // Read file with UTF-8 support
    std::vector<uint8_t> file_data;
    if (!read_file_utf8(filepath, file_data)) {
        log_message("Failed to read model file");
        return false;
    }
    
    cgltf_options options = {};
    options.file.read = cgltf_read_file_utf8;
    options.file.release = cgltf_release_file_utf8;
    
    cgltf_data* data = nullptr;
    
    // Parse from memory
    cgltf_result result = cgltf_parse(&options, file_data.data(), file_data.size(), &data);
    if (result != cgltf_result_success) {
        log_message("Failed to parse GLTF file");
        return false;
    }
    
    // Load buffers (uses our custom file read callback for external files)
    result = cgltf_load_buffers(&options, data, filepath);
    if (result != cgltf_result_success) {
        log_message("Failed to load GLTF buffers");
        cgltf_free(data);
        return false;
    }
    
    // Check if VRM model
    state.is_vrm_model = false;
    if (data->extensions_used && data->extensions_used_count > 0) {
        for (size_t i = 0; i < data->extensions_used_count; i++) {
            if (strstr(data->extensions_used[i], "VRM") || strstr(data->extensions_used[i], "vrm")) {
                state.is_vrm_model = true;
                break;
            }
        }
    }
    
    // Clear existing model
    for (auto& mesh : state.model.meshes) {
        sg_destroy_buffer(mesh.vertex_buffer);
        if (mesh.has_indices) {
            sg_destroy_buffer(mesh.index_buffer);
        }
        // Clean up PBR material textures
        if (mesh.material.base_color_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.base_color_view);
            sg_destroy_image(mesh.material.base_color_tex);
        }
        if (mesh.material.metallic_roughness_tex.id != state.default_metallic_roughness.id) {
            sg_destroy_view(mesh.material.metallic_roughness_view);
            sg_destroy_image(mesh.material.metallic_roughness_tex);
        }
        if (mesh.material.normal_tex.id != state.default_normal.id) {
            sg_destroy_view(mesh.material.normal_view);
            sg_destroy_image(mesh.material.normal_tex);
        }
        if (mesh.material.occlusion_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.occlusion_view);
            sg_destroy_image(mesh.material.occlusion_tex);
        }
        if (mesh.material.emissive_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.emissive_view);
            sg_destroy_image(mesh.material.emissive_tex);
        }
    }
    state.model.meshes.clear();
    
    // Calculate bounding box for camera positioning
    HMM_Vec3 min_bounds = HMM_V3(1e10f, 1e10f, 1e10f);
    HMM_Vec3 max_bounds = HMM_V3(-1e10f, -1e10f, -1e10f);
    
    // Load textures
    std::vector<sg_image> textures(data->images_count, state.default_texture);
    std::vector<sg_view> texture_views(data->images_count, state.default_texture_view);
    for (size_t i = 0; i < data->images_count; i++) {
        cgltf_image* image = &data->images[i];
        
        if (image->buffer_view) {
            // Embedded texture
            const uint8_t* buffer_data = (const uint8_t*)image->buffer_view->buffer->data;
            buffer_data += image->buffer_view->offset;
            textures[i] = load_texture_from_buffer(buffer_data, image->buffer_view->size);
        } else if (image->uri) {
            // External texture file
            textures[i] = load_texture_from_file(filepath, image->uri);
        }
        
        // Create view for texture if it's not the default
        if (textures[i].id != state.default_texture.id) {
            texture_views[i] = create_texture_view(textures[i]);
        }
    }
    
    // Process all meshes in all nodes
    for (size_t ni = 0; ni < data->nodes_count; ni++) {
        cgltf_node* node = &data->nodes[ni];
        if (!node->mesh) continue;
        
        // Get node transform
        float node_matrix[16];
        cgltf_node_transform_world(node, node_matrix);
        
        cgltf_mesh* mesh = node->mesh;
        
        for (size_t pi = 0; pi < mesh->primitives_count; pi++) {
            cgltf_primitive* prim = &mesh->primitives[pi];
            
            if (prim->type != cgltf_primitive_type_triangles) {
                continue;
            }
            
            // Find position, normal, texcoord, and tangent accessors
            cgltf_accessor* pos_accessor = nullptr;
            cgltf_accessor* norm_accessor = nullptr;
            cgltf_accessor* uv_accessor = nullptr;
            cgltf_accessor* tangent_accessor = nullptr;
            
            for (size_t ai = 0; ai < prim->attributes_count; ai++) {
                cgltf_attribute* attr = &prim->attributes[ai];
                switch (attr->type) {
                    case cgltf_attribute_type_position:
                        pos_accessor = attr->data;
                        break;
                    case cgltf_attribute_type_normal:
                        norm_accessor = attr->data;
                        break;
                    case cgltf_attribute_type_texcoord:
                        if (attr->index == 0) {
                            uv_accessor = attr->data;
                        }
                        break;
                    case cgltf_attribute_type_tangent:
                        tangent_accessor = attr->data;
                        break;
                    default:
                        break;
                }
            }
            
            if (!pos_accessor) {
                continue;
            }
            
            size_t vertex_count = pos_accessor->count;
            std::vector<Vertex> vertices(vertex_count);
            
            // Read positions
            for (size_t vi = 0; vi < vertex_count; vi++) {
                float pos[3] = {0, 0, 0};
                cgltf_accessor_read_float(pos_accessor, vi, pos, 3);
                
                // Apply node transform
                float tx = node_matrix[0]*pos[0] + node_matrix[4]*pos[1] + node_matrix[8]*pos[2] + node_matrix[12];
                float ty = node_matrix[1]*pos[0] + node_matrix[5]*pos[1] + node_matrix[9]*pos[2] + node_matrix[13];
                float tz = node_matrix[2]*pos[0] + node_matrix[6]*pos[1] + node_matrix[10]*pos[2] + node_matrix[14];
                
                vertices[vi].pos[0] = tx;
                vertices[vi].pos[1] = ty;
                vertices[vi].pos[2] = tz;
                
                // Update bounds
                min_bounds.X = HMM_MIN(min_bounds.X, tx);
                min_bounds.Y = HMM_MIN(min_bounds.Y, ty);
                min_bounds.Z = HMM_MIN(min_bounds.Z, tz);
                max_bounds.X = HMM_MAX(max_bounds.X, tx);
                max_bounds.Y = HMM_MAX(max_bounds.Y, ty);
                max_bounds.Z = HMM_MAX(max_bounds.Z, tz);
            }
            
            // Read normals
            if (norm_accessor) {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    float norm[3] = {0, 1, 0};
                    cgltf_accessor_read_float(norm_accessor, vi, norm, 3);
                    
                    // Apply node rotation (ignore scale for normals)
                    float nx = node_matrix[0]*norm[0] + node_matrix[4]*norm[1] + node_matrix[8]*norm[2];
                    float ny = node_matrix[1]*norm[0] + node_matrix[5]*norm[1] + node_matrix[9]*norm[2];
                    float nz = node_matrix[2]*norm[0] + node_matrix[6]*norm[1] + node_matrix[10]*norm[2];
                    float len = sqrtf(nx*nx + ny*ny + nz*nz);
                    if (len > 0.0001f) {
                        vertices[vi].normal[0] = nx / len;
                        vertices[vi].normal[1] = ny / len;
                        vertices[vi].normal[2] = nz / len;
                    } else {
                        vertices[vi].normal[0] = 0;
                        vertices[vi].normal[1] = 1;
                        vertices[vi].normal[2] = 0;
                    }
                }
            } else {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    vertices[vi].normal[0] = 0;
                    vertices[vi].normal[1] = 1;
                    vertices[vi].normal[2] = 0;
                }
            }
            
            // Read UVs
            if (uv_accessor) {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    float uv[2] = {0, 0};
                    cgltf_accessor_read_float(uv_accessor, vi, uv, 2);
                    vertices[vi].uv[0] = uv[0];
                    vertices[vi].uv[1] = uv[1];
                }
            } else {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    vertices[vi].uv[0] = 0;
                    vertices[vi].uv[1] = 0;
                }
            }
            
            // Read tangents
            if (tangent_accessor) {
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    float tangent[4] = {1, 0, 0, 1};
                    cgltf_accessor_read_float(tangent_accessor, vi, tangent, 4);
                    
                    // Apply node rotation to tangent
                    float tx = node_matrix[0]*tangent[0] + node_matrix[4]*tangent[1] + node_matrix[8]*tangent[2];
                    float ty = node_matrix[1]*tangent[0] + node_matrix[5]*tangent[1] + node_matrix[9]*tangent[2];
                    float tz = node_matrix[2]*tangent[0] + node_matrix[6]*tangent[1] + node_matrix[10]*tangent[2];
                    float len = sqrtf(tx*tx + ty*ty + tz*tz);
                    if (len > 0.0001f) {
                        vertices[vi].tangent[0] = tx / len;
                        vertices[vi].tangent[1] = ty / len;
                        vertices[vi].tangent[2] = tz / len;
                    } else {
                        vertices[vi].tangent[0] = 1;
                        vertices[vi].tangent[1] = 0;
                        vertices[vi].tangent[2] = 0;
                    }
                    vertices[vi].tangent[3] = tangent[3];  // Sign for bitangent
                }
            } else {
                // Generate default tangent if not present
                for (size_t vi = 0; vi < vertex_count; vi++) {
                    vertices[vi].tangent[0] = 1;
                    vertices[vi].tangent[1] = 0;
                    vertices[vi].tangent[2] = 0;
                    vertices[vi].tangent[3] = 1;
                }
            }
            
            // Create render mesh
            RenderMesh render_mesh = {};
            
            // Create vertex buffer
            sg_buffer_desc vbuf_desc = {};
            vbuf_desc.data = { vertices.data(), vertices.size() * sizeof(Vertex) };
            vbuf_desc.label = "mesh-vertices";
            render_mesh.vertex_buffer = sg_make_buffer(&vbuf_desc);
            render_mesh.num_vertices = (int)vertex_count;
            
            // Read indices if available
            if (prim->indices) {
                size_t index_count = prim->indices->count;
                std::vector<uint32_t> indices(index_count);
                
                for (size_t ii = 0; ii < index_count; ii++) {
                    indices[ii] = (uint32_t)cgltf_accessor_read_index(prim->indices, ii);
                }
                
                sg_buffer_desc ibuf_desc = {};
                ibuf_desc.usage.index_buffer = true;
                ibuf_desc.data = { indices.data(), indices.size() * sizeof(uint32_t) };
                ibuf_desc.label = "mesh-indices";
                render_mesh.index_buffer = sg_make_buffer(&ibuf_desc);
                render_mesh.num_indices = (int)index_count;
                render_mesh.has_indices = true;
            } else {
                render_mesh.has_indices = false;
            }
            
            // Initialize PBR material with defaults
            PBRMaterial material = {};
            material.base_color_tex = state.default_texture;
            material.base_color_view = state.default_texture_view;
            material.metallic_roughness_tex = state.default_metallic_roughness;
            material.metallic_roughness_view = state.default_metallic_roughness_view;
            material.normal_tex = state.default_normal;
            material.normal_view = state.default_normal_view;
            material.occlusion_tex = state.default_texture;
            material.occlusion_view = state.default_texture_view;
            material.emissive_tex = state.default_texture;
            material.emissive_view = state.default_texture_view;
            
            material.base_color_factor = HMM_V4(1.0f, 1.0f, 1.0f, 1.0f);
            material.metallic_factor = 1.0f;
            material.roughness_factor = 1.0f;
            material.emissive_factor = HMM_V3(0.0f, 0.0f, 0.0f);
            
            material.is_vrm = state.is_vrm_model;
            material.toon_ramp_steps = 4.0f;
            material.toon_rim_power = 2.0f;
            material.toon_rim_strength = 0.5f;
            
            // Load PBR material from GLTF
            if (prim->material) {
                cgltf_material* mat = prim->material;
                
                if (mat->has_pbr_metallic_roughness) {
                    cgltf_pbr_metallic_roughness* pbr = &mat->pbr_metallic_roughness;
                    
                    material.base_color_factor = HMM_V4(
                        pbr->base_color_factor[0],
                        pbr->base_color_factor[1],
                        pbr->base_color_factor[2],
                        pbr->base_color_factor[3]
                    );
                    material.metallic_factor = pbr->metallic_factor;
                    material.roughness_factor = pbr->roughness_factor;
                    
                    // Base color texture
                    if (pbr->base_color_texture.texture) {
                        cgltf_texture* tex = pbr->base_color_texture.texture;
                        if (tex->image) {
                            size_t img_idx = tex->image - data->images;
                            if (img_idx < textures.size()) {
                                material.base_color_tex = textures[img_idx];
                                material.base_color_view = texture_views[img_idx];
                            }
                        }
                    }
                    
                    // Metallic-roughness texture
                    if (pbr->metallic_roughness_texture.texture) {
                        cgltf_texture* tex = pbr->metallic_roughness_texture.texture;
                        if (tex->image) {
                            size_t img_idx = tex->image - data->images;
                            if (img_idx < textures.size()) {
                                material.metallic_roughness_tex = textures[img_idx];
                                material.metallic_roughness_view = texture_views[img_idx];
                            }
                        }
                    }
                }
                
                // Normal texture
                if (mat->normal_texture.texture) {
                    cgltf_texture* tex = mat->normal_texture.texture;
                    if (tex->image) {
                        size_t img_idx = tex->image - data->images;
                        if (img_idx < textures.size()) {
                            material.normal_tex = textures[img_idx];
                            material.normal_view = texture_views[img_idx];
                        }
                    }
                }
                
                // Occlusion texture
                if (mat->occlusion_texture.texture) {
                    cgltf_texture* tex = mat->occlusion_texture.texture;
                    if (tex->image) {
                        size_t img_idx = tex->image - data->images;
                        if (img_idx < textures.size()) {
                            material.occlusion_tex = textures[img_idx];
                            material.occlusion_view = texture_views[img_idx];
                        }
                    }
                }
                
                // Emissive texture
                if (mat->emissive_texture.texture) {
                    cgltf_texture* tex = mat->emissive_texture.texture;
                    if (tex->image) {
                        size_t img_idx = tex->image - data->images;
                        if (img_idx < textures.size()) {
                            material.emissive_tex = textures[img_idx];
                            material.emissive_view = texture_views[img_idx];
                        }
                    }
                }
                
                material.emissive_factor = HMM_V3(
                    mat->emissive_factor[0],
                    mat->emissive_factor[1],
                    mat->emissive_factor[2]
                );
            }
            
            render_mesh.material = material;
            
            state.model.meshes.push_back(render_mesh);
        }
    }
    
    cgltf_free(data);
    
    // Calculate model center and radius
    state.model.center = HMM_MulV3F(HMM_AddV3(min_bounds, max_bounds), 0.5f);
    HMM_Vec3 extent = HMM_SubV3(max_bounds, min_bounds);
    state.model.radius = HMM_LenV3(extent) * 0.5f;
    
    if (state.model.radius < 0.001f) {
        state.model.radius = 1.0f;
    }
    
    // Set up camera to view the model
    state.cam_target = state.model.center;
    state.cam_distance = state.model.radius * 2.5f;
    state.cam_elevation = 15.0f;
    state.cam_azimuth = 45.0f;
    
    log_message(("Loaded " + std::to_string(state.model.meshes.size()) + " mesh(es)").c_str());
    state.model_loaded = true;
    
    return true;
}

// ============================================================================
// Sokol callbacks
// ============================================================================

static void init() {
    log_message("Initializing...");
    
    // Setup sokol-gfx
    sg_desc desc = {};
    desc.environment = sglue_environment();
    desc.logger.func = slog_func;
    sg_setup(&desc);
    
    // Initialize GUI (Clay-based)
    gui_init();
    
    // Create default textures
    state.default_texture = create_default_white_texture();
    state.default_texture_view = create_texture_view(state.default_texture);
    
    // Default normal map (neutral blue)
    uint32_t normal_pixels[4] = { 0x8080FF, 0x8080FF, 0x8080FF, 0x8080FF };
    sg_image_desc normal_desc = {};
    normal_desc.width = 2;
    normal_desc.height = 2;
    normal_desc.data.mip_levels[0] = { normal_pixels, sizeof(normal_pixels) };
    normal_desc.label = "default-normal";
    state.default_normal = sg_make_image(&normal_desc);
    state.default_normal_view = create_texture_view(state.default_normal);
    
    // Default metallic-roughness (white = fully metallic, fully rough)
    uint32_t mr_pixels[4] = { 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF };
    sg_image_desc mr_desc = {};
    mr_desc.width = 2;
    mr_desc.height = 2;
    mr_desc.data.mip_levels[0] = { mr_pixels, sizeof(mr_pixels) };
    mr_desc.label = "default-metallic-roughness";
    state.default_metallic_roughness = sg_make_image(&mr_desc);
    state.default_metallic_roughness_view = create_texture_view(state.default_metallic_roughness);
    
    // Create samplers
    sg_sampler_desc smp_desc = {};
    smp_desc.min_filter = SG_FILTER_LINEAR;
    smp_desc.mag_filter = SG_FILTER_LINEAR;
    smp_desc.wrap_u = SG_WRAP_REPEAT;
    smp_desc.wrap_v = SG_WRAP_REPEAT;
    state.smp = sg_make_sampler(&smp_desc);
    
    // Cubemap sampler for IBL
    sg_sampler_desc cubemap_smp_desc = {};
    cubemap_smp_desc.min_filter = SG_FILTER_LINEAR;
    cubemap_smp_desc.mag_filter = SG_FILTER_LINEAR;
    cubemap_smp_desc.wrap_u = SG_WRAP_CLAMP_TO_EDGE;
    cubemap_smp_desc.wrap_v = SG_WRAP_CLAMP_TO_EDGE;
    cubemap_smp_desc.wrap_w = SG_WRAP_CLAMP_TO_EDGE;
    sg_sampler cubemap_smp = sg_make_sampler(&cubemap_smp_desc);
    
    // Load HDR environment and create IBL maps (generates environment cubemap + IBL maps)
    const char* hdr_path = "assets/hdr/modern_evening_street_2k.hdr";
    create_ibl_maps(hdr_path);
    
    // Create skybox geometry
    float skybox_vertices[] = {
        -1.0f,  1.0f, -1.0f,  -1.0f, -1.0f, -1.0f,   1.0f, -1.0f, -1.0f,   1.0f, -1.0f, -1.0f,   1.0f,  1.0f, -1.0f,  -1.0f,  1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f,  -1.0f, -1.0f, -1.0f,  -1.0f,  1.0f, -1.0f,  -1.0f,  1.0f, -1.0f,  -1.0f,  1.0f,  1.0f,  -1.0f, -1.0f,  1.0f,
         1.0f, -1.0f, -1.0f,   1.0f, -1.0f,  1.0f,   1.0f,  1.0f,  1.0f,   1.0f,  1.0f,  1.0f,   1.0f,  1.0f, -1.0f,   1.0f, -1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f,  -1.0f,  1.0f,  1.0f,   1.0f,  1.0f,  1.0f,   1.0f,  1.0f,  1.0f,   1.0f, -1.0f,  1.0f,  -1.0f, -1.0f,  1.0f,
        -1.0f,  1.0f, -1.0f,   1.0f,  1.0f, -1.0f,   1.0f,  1.0f,  1.0f,   1.0f,  1.0f,  1.0f,  -1.0f,  1.0f,  1.0f,  -1.0f,  1.0f, -1.0f,
        -1.0f, -1.0f, -1.0f,  -1.0f, -1.0f,  1.0f,   1.0f, -1.0f, -1.0f,   1.0f, -1.0f, -1.0f,  -1.0f, -1.0f,  1.0f,   1.0f, -1.0f,  1.0f
    };
    sg_buffer_desc skybox_vbuf_desc = {};
    skybox_vbuf_desc.data = { skybox_vertices, sizeof(skybox_vertices) };
    skybox_vbuf_desc.label = "skybox-vertices";
    state.skybox_vertex_buffer = sg_make_buffer(&skybox_vbuf_desc);
    
    uint16_t skybox_indices[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35 };
    sg_buffer_desc skybox_ibuf_desc = {};
    skybox_ibuf_desc.usage.index_buffer = true;
    skybox_ibuf_desc.data = { skybox_indices, sizeof(skybox_indices) };
    skybox_ibuf_desc.label = "skybox-indices";
    state.skybox_index_buffer = sg_make_buffer(&skybox_ibuf_desc);
    
    // Create PBR shader
    sg_shader pbr_shd = sg_make_shader(pbr_pbr_shader_desc(sg_query_backend()));
    sg_pipeline_desc pbr_pip_desc = {};
    pbr_pip_desc.shader = pbr_shd;
    pbr_pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT3;  // position
    pbr_pip_desc.layout.attrs[1].format = SG_VERTEXFORMAT_FLOAT3;  // normal
    pbr_pip_desc.layout.attrs[2].format = SG_VERTEXFORMAT_FLOAT2;  // uv
    pbr_pip_desc.layout.attrs[3].format = SG_VERTEXFORMAT_FLOAT4;  // tangent
    pbr_pip_desc.index_type = SG_INDEXTYPE_UINT32;
    pbr_pip_desc.cull_mode = SG_CULLMODE_NONE;
    pbr_pip_desc.depth.write_enabled = true;
    pbr_pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    pbr_pip_desc.label = "pbr-pipeline";
    state.pbr_pip = sg_make_pipeline(&pbr_pip_desc);
    
    // Create toon shader
    sg_shader toon_shd = sg_make_shader(toon_toon_shader_desc(sg_query_backend()));
    sg_pipeline_desc toon_pip_desc = {};
    toon_pip_desc.shader = toon_shd;
    toon_pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT3;  // position
    toon_pip_desc.layout.attrs[1].format = SG_VERTEXFORMAT_FLOAT3;  // normal
    toon_pip_desc.layout.attrs[2].format = SG_VERTEXFORMAT_FLOAT2;  // uv
    toon_pip_desc.layout.attrs[3].format = SG_VERTEXFORMAT_FLOAT4;  // tangent
    toon_pip_desc.index_type = SG_INDEXTYPE_UINT32;
    toon_pip_desc.cull_mode = SG_CULLMODE_NONE;
    toon_pip_desc.depth.write_enabled = true;
    toon_pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    toon_pip_desc.label = "toon-pipeline";
    state.toon_pip = sg_make_pipeline(&toon_pip_desc);
    
    // Create skybox shader
    sg_shader skybox_shd = sg_make_shader(skybox_skybox_shader_desc(sg_query_backend()));
    sg_pipeline_desc skybox_pip_desc = {};
    skybox_pip_desc.shader = skybox_shd;
    skybox_pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT3;  // position
    skybox_pip_desc.index_type = SG_INDEXTYPE_UINT16;
    skybox_pip_desc.cull_mode = SG_CULLMODE_FRONT;  // Inside-out rendering
    skybox_pip_desc.depth.write_enabled = false;
    skybox_pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    skybox_pip_desc.label = "skybox-pipeline";
    state.skybox_pip = sg_make_pipeline(&skybox_pip_desc);
    
    // Old simple pipeline (kept for compatibility)
    sg_shader shd = sg_make_shader(mesh_mesh_shader_desc(sg_query_backend()));
    sg_pipeline_desc pip_desc = {};
    pip_desc.shader = shd;
    pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT3;  // position
    pip_desc.layout.attrs[1].format = SG_VERTEXFORMAT_FLOAT3;  // normal
    pip_desc.layout.attrs[2].format = SG_VERTEXFORMAT_FLOAT2;  // uv
    pip_desc.index_type = SG_INDEXTYPE_UINT32;
    pip_desc.cull_mode = SG_CULLMODE_NONE;
    pip_desc.depth.write_enabled = true;
    pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    pip_desc.label = "mesh-pipeline";
    state.pip = sg_make_pipeline(&pip_desc);
    
    // Initialize camera
    state.cam_distance = 5.0f;
    state.cam_azimuth = 45.0f;
    state.cam_elevation = 20.0f;
    state.cam_target = HMM_V3(0, 0, 0);
    
    state.mouse_down = false;
    state.time = 0.0f;
    state.model_loaded = false;
    state.is_vrm_model = false;
    
    // Skybox settings
    state.skybox_lod = 0.0f;
    state.skybox_exposure = 1.0f;
    state.show_skybox = true;
    
    // GUI settings
    state.show_gui = true;
    state.gui_hovered = false;
    
    // Toon shader defaults (matching toon.glsl)
    state.toon_light_intensity = 1.0f;
    state.toon_shade_toony = 0.5f;
    state.toon_shade_strength = 0.65f;
    state.toon_rim_threshold = 0.7f;
    state.toon_rim_softness = 0.3f;
    state.toon_spec_intensity = 0.3f;
    
    log_message("Ready. Drag and drop a VRM/GLTF/GLB file to load.");
    log_message("Press 'G' to toggle GUI, 'S' to toggle skybox");
}

static void frame() {
    state.time += (float)sapp_frame_duration();
    
    // Start new GUI frame
    gui_new_frame();
    
    // Check if mouse is over GUI (for blocking 3D interactions)
    state.gui_hovered = state.show_gui && gui_is_hovered();
    
    // Calculate camera position
    float azimuth_rad = HMM_AngleRad(state.cam_azimuth);
    float elevation_rad = HMM_AngleRad(state.cam_elevation);
    
    float cos_elev = cosf(elevation_rad);
    float sin_elev = sinf(elevation_rad);
    float cos_azim = cosf(azimuth_rad);
    float sin_azim = sinf(azimuth_rad);
    
    HMM_Vec3 cam_offset = HMM_V3(
        cos_elev * sin_azim * state.cam_distance,
        sin_elev * state.cam_distance,
        cos_elev * cos_azim * state.cam_distance
    );
    HMM_Vec3 cam_pos = HMM_AddV3(state.cam_target, cam_offset);
    
    // Build view and projection matrices
    float aspect = sapp_widthf() / sapp_heightf();
    HMM_Mat4 proj = HMM_Perspective_RH_ZO(45.0f, aspect, 0.01f, 1000.0f);
    HMM_Mat4 view = HMM_LookAt_RH(cam_pos, state.cam_target, HMM_V3(0, 1, 0));
    HMM_Mat4 model = HMM_M4D(1.0f);
    HMM_Mat4 mvp = HMM_MulM4(proj, HMM_MulM4(view, model));
    
    // Light direction (from camera towards scene)
    HMM_Vec3 light_dir = HMM_NormV3(HMM_V3(0.5f, 1.0f, 0.3f));
    
    // Build normal matrix for PBR
    HMM_Mat4 normal_matrix = HMM_TransposeM4(HMM_InvGeneralM4(model));
    
    // Begin pass
    sg_pass pass = {};
    pass.swapchain = sglue_swapchain();
    pass.action.colors[0].load_action = SG_LOADACTION_CLEAR;
    pass.action.colors[0].clear_value = { 0.0f, 0.0f, 0.0f, 1.0f };
    pass.action.depth.load_action = SG_LOADACTION_CLEAR;
    pass.action.depth.clear_value = 1.0f;
    sg_begin_pass(&pass);
    
    // Render skybox first (if enabled)
    if (state.show_skybox && state.hdr_environment.id != SG_INVALID_ID) {
        sg_apply_pipeline(state.skybox_pip);
        
        sg_bindings skybox_bind = {};
        skybox_bind.vertex_buffers[0] = state.skybox_vertex_buffer;
        skybox_bind.index_buffer = state.skybox_index_buffer;
        skybox_bind.views[VIEW_skybox_environment_map] = state.hdr_environment_view;  // Use environment cubemap for skybox
        skybox_bind.samplers[SMP_skybox_env_smp] = state.smp;
        sg_apply_bindings(&skybox_bind);
        
        // Skybox uses view matrix without translation
        HMM_Mat4 skybox_view = view;
        skybox_view.Elements[0][3] = 0.0f;
        skybox_view.Elements[1][3] = 0.0f;
        skybox_view.Elements[2][3] = 0.0f;
        skybox_view.Elements[3][0] = 0.0f;
        skybox_view.Elements[3][1] = 0.0f;
        skybox_view.Elements[3][2] = 0.0f;
        HMM_Mat4 skybox_mvp = HMM_MulM4(proj, skybox_view);
        
        // Skybox vertex shader uniforms
        skybox_vs_params_t skybox_vs = {};
        skybox_vs.mvp = skybox_mvp;
        skybox_vs.cam_pos = cam_pos;
        sg_apply_uniforms(UB_skybox_vs_params, SG_RANGE(skybox_vs));
        
        // Skybox fragment shader uniforms
        skybox_fs_params_t skybox_fs = {};
        skybox_fs.lod_level = state.skybox_lod;
        skybox_fs.exposure = state.skybox_exposure;
        sg_apply_uniforms(UB_skybox_fs_params, SG_RANGE(skybox_fs));
        
        sg_draw(0, 36, 1);
    }
    
    // Render model with PBR or toon shader
    if (state.model_loaded) {
        for (auto& mesh : state.model.meshes) {
            // Choose shader based on material
            if (mesh.material.is_vrm) {
                sg_apply_pipeline(state.toon_pip);
            } else {
                sg_apply_pipeline(state.pbr_pip);
            }
            
            // Set up bindings
            sg_bindings bind = {};
            bind.vertex_buffers[0] = mesh.vertex_buffer;
            if (mesh.has_indices) {
                bind.index_buffer = mesh.index_buffer;
            }
            
            // PBR/Toon texture bindings (using generated constants)
            if (mesh.material.is_vrm) {
                // Toon shader bindings
                bind.views[VIEW_toon_base_color_tex] = mesh.material.base_color_view;
                bind.samplers[SMP_toon_base_color_smp] = state.smp;
                bind.views[VIEW_toon_metallic_roughness_tex] = mesh.material.metallic_roughness_view;
                bind.samplers[SMP_toon_metallic_roughness_smp] = state.smp;
                bind.views[VIEW_toon_normal_tex] = mesh.material.normal_view;
                bind.samplers[SMP_toon_normal_smp] = state.smp;
                bind.views[VIEW_toon_irradiance_map] = state.irradiance_map_view;
                bind.samplers[SMP_toon_irradiance_smp] = state.smp;
                bind.views[VIEW_toon_prefilter_map] = state.prefilter_map_view;
                bind.samplers[SMP_toon_prefilter_smp] = state.smp;
            } else {
                // PBR shader bindings
                bind.views[VIEW_pbr_base_color_tex] = mesh.material.base_color_view;
                bind.samplers[SMP_pbr_base_color_smp] = state.smp;
                bind.views[VIEW_pbr_metallic_roughness_tex] = mesh.material.metallic_roughness_view;
                bind.samplers[SMP_pbr_metallic_roughness_smp] = state.smp;
                bind.views[VIEW_pbr_normal_tex] = mesh.material.normal_view;
                bind.samplers[SMP_pbr_normal_smp] = state.smp;
                bind.views[VIEW_pbr_occlusion_tex] = mesh.material.occlusion_view;
                bind.samplers[SMP_pbr_occlusion_smp] = state.smp;
                bind.views[VIEW_pbr_emissive_tex] = mesh.material.emissive_view;
                bind.samplers[SMP_pbr_emissive_smp] = state.smp;
                bind.views[VIEW_pbr_irradiance_map] = state.irradiance_map_view;
                bind.samplers[SMP_pbr_irradiance_smp] = state.smp;
                bind.views[VIEW_pbr_prefilter_map] = state.prefilter_map_view;
                bind.samplers[SMP_pbr_prefilter_smp] = state.smp;
                bind.views[VIEW_pbr_brdf_lut] = state.brdf_lut_view;
                bind.samplers[SMP_pbr_brdf_lut_smp] = state.smp;
            }
            
            sg_apply_bindings(&bind);
            
            // Vertex shader uniforms
            if (mesh.material.is_vrm) {
                toon_vs_params_t vs_uniforms = {};
                vs_uniforms.mvp = mvp;
                vs_uniforms.model = model;
                vs_uniforms.normal_matrix = normal_matrix;
                vs_uniforms.cam_pos = cam_pos;
                sg_apply_uniforms(UB_toon_vs_params, SG_RANGE(vs_uniforms));
            } else {
                pbr_vs_params_t vs_uniforms = {};
                vs_uniforms.mvp = mvp;
                vs_uniforms.model = model;
                vs_uniforms.normal_matrix = normal_matrix;
                vs_uniforms.cam_pos = cam_pos;
                sg_apply_uniforms(UB_pbr_vs_params, SG_RANGE(vs_uniforms));
            }
            
            // Fragment shader uniforms
            if (mesh.material.is_vrm) {
                toon_fs_params_t fs_uniforms = {};
                fs_uniforms.base_color_factor = mesh.material.base_color_factor;
                fs_uniforms.metallic_factor = mesh.material.metallic_factor;
                fs_uniforms.roughness_factor = mesh.material.roughness_factor;
                fs_uniforms.toon_ramp_steps = mesh.material.toon_ramp_steps;
                fs_uniforms.toon_rim_power = mesh.material.toon_rim_power;
                fs_uniforms.toon_rim_strength = mesh.material.toon_rim_strength;
                fs_uniforms.cam_pos = cam_pos;
                sg_apply_uniforms(UB_toon_fs_params, SG_RANGE(fs_uniforms));
            } else {
                pbr_fs_params_t fs_uniforms = {};
                fs_uniforms.base_color_factor = mesh.material.base_color_factor;
                fs_uniforms.metallic_factor = mesh.material.metallic_factor;
                fs_uniforms.roughness_factor = mesh.material.roughness_factor;
                fs_uniforms.emissive_factor = mesh.material.emissive_factor;
                fs_uniforms.cam_pos = cam_pos;
                sg_apply_uniforms(UB_pbr_fs_params, SG_RANGE(fs_uniforms));
            }
            
            // Draw
            if (mesh.has_indices) {
                sg_draw(0, mesh.num_indices, 1);
            } else {
                sg_draw(0, mesh.num_vertices, 1);
            }
        }
    }
    
    // Render GUI
    GuiState gui_state = {};
    gui_state.model_loaded = state.model_loaded;
    gui_state.is_vrm_model = state.is_vrm_model;
    gui_state.mesh_count = (int)state.model.meshes.size();
    gui_state.show_skybox = state.show_skybox;
    gui_state.skybox_exposure = state.skybox_exposure;
    gui_state.skybox_lod = state.skybox_lod;
    gui_state.toon_light_intensity = state.toon_light_intensity;
    gui_state.toon_shade_toony = state.toon_shade_toony;
    gui_state.toon_shade_strength = state.toon_shade_strength;
    gui_state.toon_rim_threshold = state.toon_rim_threshold;
    gui_state.toon_rim_softness = state.toon_rim_softness;
    gui_state.toon_spec_intensity = state.toon_spec_intensity;
    gui_state.show_gui = state.show_gui;
    gui_state.gui_hovered = state.gui_hovered;
    gui_state.mouse_pressed = state.mouse_down;
    gui_state.mouse_x = state.last_mouse_x;
    gui_state.mouse_y = state.last_mouse_y;
    gui_render(&gui_state);
    
    // Sync GUI changes back to application state
    state.show_skybox = gui_state.show_skybox;
    state.skybox_exposure = gui_state.skybox_exposure;
    state.skybox_lod = gui_state.skybox_lod;
    state.toon_light_intensity = gui_state.toon_light_intensity;
    state.toon_shade_toony = gui_state.toon_shade_toony;
    state.toon_shade_strength = gui_state.toon_shade_strength;
    state.toon_rim_threshold = gui_state.toon_rim_threshold;
    state.toon_rim_softness = gui_state.toon_rim_softness;
    state.toon_spec_intensity = gui_state.toon_spec_intensity;
    
    sg_end_pass();
    sg_commit();
}

static void cleanup() {
    log_message("Cleaning up...");
    
    // Clean up model resources
    for (auto& mesh : state.model.meshes) {
        sg_destroy_buffer(mesh.vertex_buffer);
        if (mesh.has_indices) {
            sg_destroy_buffer(mesh.index_buffer);
        }
        // Clean up PBR material textures
        if (mesh.material.base_color_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.base_color_view);
            sg_destroy_image(mesh.material.base_color_tex);
        }
        if (mesh.material.metallic_roughness_tex.id != state.default_metallic_roughness.id) {
            sg_destroy_view(mesh.material.metallic_roughness_view);
            sg_destroy_image(mesh.material.metallic_roughness_tex);
        }
        if (mesh.material.normal_tex.id != state.default_normal.id) {
            sg_destroy_view(mesh.material.normal_view);
            sg_destroy_image(mesh.material.normal_tex);
        }
        if (mesh.material.occlusion_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.occlusion_view);
            sg_destroy_image(mesh.material.occlusion_tex);
        }
        if (mesh.material.emissive_tex.id != state.default_texture.id) {
            sg_destroy_view(mesh.material.emissive_view);
            sg_destroy_image(mesh.material.emissive_tex);
        }
    }
    
    // Clean up skybox
    sg_destroy_buffer(state.skybox_vertex_buffer);
    sg_destroy_buffer(state.skybox_index_buffer);
    
    // Clean up IBL resources
    sg_destroy_view(state.brdf_lut_view);
    sg_destroy_image(state.brdf_lut);
    sg_destroy_view(state.prefilter_map_view);
    sg_destroy_image(state.prefilter_map);
    sg_destroy_view(state.irradiance_map_view);
    sg_destroy_image(state.irradiance_map);
    sg_destroy_view(state.hdr_environment_view);
    sg_destroy_image(state.hdr_environment);
    
    // Clean up default textures
    sg_destroy_view(state.default_metallic_roughness_view);
    sg_destroy_image(state.default_metallic_roughness);
    sg_destroy_view(state.default_normal_view);
    sg_destroy_image(state.default_normal);
    sg_destroy_view(state.default_texture_view);
    sg_destroy_image(state.default_texture);
    
    // Clean up pipelines
    sg_destroy_sampler(state.smp);
    sg_destroy_pipeline(state.skybox_pip);
    sg_destroy_pipeline(state.toon_pip);
    sg_destroy_pipeline(state.pbr_pip);
    sg_destroy_pipeline(state.pip);
    
    // Cleanup GUI
    gui_shutdown();
    
    sg_shutdown();
}

static void event(const sapp_event* ev) {
    // Pass events to GUI
    gui_handle_event(ev);
    
    switch (ev->type) {
        case SAPP_EVENTTYPE_MOUSE_DOWN:
            if (ev->mouse_button == SAPP_MOUSEBUTTON_LEFT) {
                state.mouse_down = true;
                state.last_mouse_x = ev->mouse_x;
                state.last_mouse_y = ev->mouse_y;
            }
            break;
            
        case SAPP_EVENTTYPE_MOUSE_UP:
            if (ev->mouse_button == SAPP_MOUSEBUTTON_LEFT) {
                state.mouse_down = false;
            }
            break;
            
        case SAPP_EVENTTYPE_MOUSE_MOVE:
            // Camera rotation only when dragging outside GUI
            if (state.mouse_down && !state.gui_hovered) {
                float dx = ev->mouse_x - state.last_mouse_x;
                float dy = ev->mouse_y - state.last_mouse_y;
                
                state.cam_azimuth -= dx * 0.001f;
                state.cam_elevation += dy * 0.001f;
                
                // Clamp elevation
                state.cam_elevation = HMM_Clamp(-89.0f, state.cam_elevation, 89.0f);
            }
            // Always update mouse position for GUI interactions
            state.last_mouse_x = ev->mouse_x;
            state.last_mouse_y = ev->mouse_y;
            break;
            
        case SAPP_EVENTTYPE_MOUSE_SCROLL:
            // Don't zoom if over GUI
            if (!state.gui_hovered) {
                state.cam_distance -= ev->scroll_y * state.cam_distance * 0.1f;
                state.cam_distance = HMM_MAX(0.1f, state.cam_distance);
            }
            break;
            
        case SAPP_EVENTTYPE_FILES_DROPPED: {
            int num_files = sapp_get_num_dropped_files();
            if (num_files > 0) {
                const char* filepath = sapp_get_dropped_file_path(0);
                load_model(filepath);
            }
            break;
        }
        
        case SAPP_EVENTTYPE_KEY_DOWN:
            if (ev->key_code == SAPP_KEYCODE_ESCAPE) {
                sapp_request_quit();
            } else if (ev->key_code == SAPP_KEYCODE_R) {
                // Reset camera
                if (state.model_loaded) {
                    state.cam_target = state.model.center;
                    state.cam_distance = state.model.radius * 2.5f;
                    state.cam_elevation = 15.0f;
                    state.cam_azimuth = 45.0f;
                }
            } else if (ev->key_code == SAPP_KEYCODE_G) {
                // Toggle GUI
                state.show_gui = !state.show_gui;
            } else if (ev->key_code == SAPP_KEYCODE_S) {
                // Toggle skybox
                state.show_skybox = !state.show_skybox;
            } else if (ev->key_code == SAPP_KEYCODE_EQUAL || ev->key_code == SAPP_KEYCODE_KP_ADD) {
                // Increase exposure
                state.skybox_exposure = HMM_MIN(state.skybox_exposure + 0.1f, 5.0f);
            } else if (ev->key_code == SAPP_KEYCODE_MINUS || ev->key_code == SAPP_KEYCODE_KP_SUBTRACT) {
                // Decrease exposure
                state.skybox_exposure = HMM_MAX(state.skybox_exposure - 0.1f, 0.1f);
            } else if (ev->key_code == SAPP_KEYCODE_LEFT_BRACKET) {
                // Decrease LOD
                state.skybox_lod = HMM_MAX(state.skybox_lod - 0.5f, 0.0f);
            } else if (ev->key_code == SAPP_KEYCODE_RIGHT_BRACKET) {
                // Increase LOD
                state.skybox_lod = HMM_MIN(state.skybox_lod + 0.5f, 4.0f);
            }
            break;
            
        default:
            break;
    }
}

sapp_desc sokol_main(int argc, char* argv[]) {
    sapp_desc desc = {};
    desc.init_cb = init;
    desc.frame_cb = frame;
    desc.cleanup_cb = cleanup;
    desc.event_cb = event;
    desc.width = 1280;
    desc.height = 720;
    desc.window_title = "VRM/GLTF/GLB Viewer";
    desc.icon.sokol_default = true;
    desc.enable_dragndrop = true;
    desc.max_dropped_files = 1;
    desc.logger.func = slog_func;
    desc.high_dpi = true;
    // desc.win32.console_create = true;
    
    return desc;
}
